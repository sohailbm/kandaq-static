<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://fonts.googleapis.com; font-src 'self' https://cdn.jsdelivr.net https://fonts.gstatic.com data:; img-src 'self' https://mapsredmond.org data: blob:; default-src 'self' data: blob:;">
    <title>Muslim Association of Puget Sound - Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìä</text></svg>" type="image/svg+xml">
    
    <!-- Google Fonts - Poppins -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome Icons -->
    <link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" rel="stylesheet">
    
    <!-- Data Decryption (for encrypted static files) -->
    <script src="js/decrypt.js"></script>
    
    <!-- Crema Client (for query abstraction) -->
    <script src="js/crema-client.js"></script>
    
    <style>
        
:root {
    /* Primary brand colors */
    --primary-color: #A51D35;
    --primary-hover: #8B1A2E;
    --accent-color: #8B1A2E;
    
    /* Light mode colors */
    --bg-primary: #FFFFFF;
    --bg-secondary: #F9FAFB;
    --bg-tertiary: #F3F4F6;
    --text-primary: #111827;
    --text-secondary: #6B7280;
    --text-tertiary: #9CA3AF;
    --border-color: #E5E7EB;
    --border-hover: #D1D5DB;
    
    /* Control colors (light mode) */
    --control-bg: #FFFFFF;
    --control-text: #111827;
    --control-border: #E5E7EB;
    --control-hover-bg: #F9FAFB;
    --button-primary-bg: #A51D35;
    --button-primary-text: #FFFFFF;
    --button-secondary-bg: #F3F4F6;
    --button-secondary-text: #374151;
    
    /* Font and spacing */
    --font-family: Poppins, sans-serif;
    --border-radius: 8px;
    --spacing: 16px;
}

* {
    box-sizing: border-box;
}

body {
    font-family: Poppins, sans-serif, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #A51D35 0%, #8B1A2E 50%, #f0f4f8 100%);
    background-attachment: fixed;
    color: #242424;
    margin: 0;
    padding: 0;
    min-height: 100vh;
    line-height: 1.6;
}

/* Dark mode support - DISABLED */

.btn-primary {
    background-color: #A51D35;
    color: #FFFFFF;
    border: none;
    border-radius: 8px;
    padding: calc(16px * 0.75) 16px;
    cursor: pointer;
    font-family: Poppins, sans-serif;
}

.btn-primary:hover {
    opacity: 0.9;
}

.card {
    background-color: #FFFFFF;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.metric-card {
    background-color: #FFFFFF;
    border-left: 4px solid #A51D35;
    border-radius: 8px;
    padding: 16px;
    transition: all 0.3s ease;
}

.metric-card.metric-match {
    border-left-color: #10b981;
    background-color: #f0fdf4;
}

.metric-card.metric-mismatch {
    border-left-color: #f59e0b;
    border-left-width: 6px;
    background-color: #fffbeb;
}

.metric-target {
    display: block;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid #e5e7eb;
    font-size: 0.875rem;
    line-height: 1.5;
    color: #111827;
    font-weight: 500;
}

.metric-card.metric-mismatch .metric-target {
    color: #ffffff;
    font-weight: 600;
}

.metric-card.metric-match .metric-target {
    color: #065f46;
    font-weight: 500;
}

.metric-match-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 0.5rem;
    vertical-align: middle;
}

.metric-target-value {
    font-weight: 600;
    color: #111827;
}

.text-primary {
    color: #A51D35;
}

.bg-primary {
    background-color: #A51D35;
}

.bg-accent {
    background-color: #8B1A2E;
}

/* Dashboard Layout */
.dashboard-grid {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    max-width: 1400px;
    margin: 0 auto;
    padding: 16px;
}

.dashboard-header {
    background: linear-gradient(135deg, #A51D35 0%, #8B1A2E 100%);
    color: #FFFFFF;
    padding: 20px 40px;
    border-radius: 15px;
    margin-bottom: 40px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    gap: 20px;
}

.dashboard-header::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    animation: pulse-glow 4s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

@keyframes pulse-glow {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.6; }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.loading-spinner {
    display: inline-block;
    font-size: 1.5rem;
    animation: spin 1s linear infinite;
    width: 1.5rem;
    height: 1.5rem;
    text-align: center;
    line-height: 1.5rem;
}

.maps-logo {
    height: 60px;
    width: auto;
    flex-shrink: 0;
    position: relative;
    z-index: 2;
    display: block;
}

.header-content {
    flex: 1;
    position: relative;
    z-index: 2;
}

.dashboard-header h1 {
    margin: 0;
    font-size: 2em;
    font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    position: relative;
    z-index: 1;
}

.dashboard-nav {
    display: flex;
    justify-content: center;
    gap: 16px;
    margin-top: 20px;
    position: relative;
    z-index: 1;
}

.nav-button {
    background: rgba(255, 255, 255, 0.2);
    color: #FFFFFF;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: var(--border-radius);
    padding: 12px 24px;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s ease;
    cursor: pointer;
    display: inline-block;
}

.nav-button:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Dark mode nav button - DISABLED */

.header-subtitle {
    margin: 0.25rem 0 0 0;
    font-size: 0.9rem;
    opacity: 0.9;
    font-weight: 400;
}

.dashboard-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: calc(16px * 1.5);
}

/* Metrics Section */
.metrics-section {
    margin-bottom: calc(16px * 1.5);
}

.metrics-section h2 {
    font-size: 2em;
    margin-bottom: 30px;
    color: #1f2937;
    font-weight: 700;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 24px;
    margin-top: 24px;
}

/* Board Analyses Grid - same layout as metrics */
.board-analyses-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 24px;
    margin-top: 24px;
}

.board-analysis-card {
    background: white;
    border-left: 4px solid #1a472a;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.board-analysis-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08);
}

.board-analysis-card.expense-card {
    border-left-color: #dc2626;
}

.metric-card {
    background: white;
    border-left: 4px solid #A51D35;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08), 0 1px 3px rgba(0, 0, 0, 0.12);
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-height: auto;
}

.metric-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 4px;
    height: 100%;
    background: #A51D35;
    transition: width 0.2s ease;
}

.metric-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08);
    border-left-color: #8B1A2E;
}

.metric-card:hover::before {
    width: 100%;
    opacity: 0.05;
}

.metric-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 16px;
    flex-shrink: 0;
}

.metric-name {
    margin: 0;
    font-size: 0.875rem;
    color: #6b7280;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.025em;
    line-height: 1.4;
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: #A51D35;
    margin: 8px 0 12px 0;
    line-height: 1.1;
    font-variant-numeric: tabular-nums;
    min-height: 3rem;
    display: flex;
    align-items: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.metric-category {
    font-size: 0.75rem;
    color: #9ca3af;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: auto;
    padding-top: 12px;
    border-top: 1px solid #f3f4f6;
    font-weight: 500;
}

.metric-trend {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.75rem;
    font-weight: 600;
    padding: 3px 8px;
    border-radius: 6px;
    margin-left: 8px;
    flex-shrink: 0;
}

.metric-trend.trend-up {
    background: rgba(16, 185, 129, 0.1);
    color: #10b981;
}

.metric-trend.trend-down {
    background: rgba(239, 68, 68, 0.1);
    color: #ef4444;
}

.metric-trend.trend-neutral {
    background: rgba(107, 114, 128, 0.1);
    color: #6b7280;
}

.metric-comparison {
    font-size: 0.8125rem;
    color: #6b7280;
    margin-top: 4px;
    font-style: italic;
}

/* Entity Types Section */
.entity-types-section {
    margin-bottom: calc(16px * 1.5);
    padding: 16px;
    background: linear-gradient(to bottom, #f9fafb, white);
    border-radius: 8px;
}

.entity-types-section h3 {
    font-size: 1.5rem;
    margin-bottom: calc(16px * 0.5);
    color: #1f2937;
}

.section-description {
    color: #6b7280;
    margin-bottom: 16px;
    font-size: 0.95rem;
}

.entity-types-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    gap: 1.5rem;
    margin-top: 16px;
}

.entity-type-card {
    background: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 8px rgba(165, 29, 53, 0.1);
    border: 2px solid rgba(165, 29, 53, 0.2);
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    gap: calc(16px * 0.75);
}

.entity-type-card:hover {
    border-color: var(--entity-color, #A51D35);
    box-shadow: 0 4px 12px rgba(165, 29, 53, 0.2);
    transform: translateY(-2px);
}

.entity-icon {
    font-size: 2rem;
    margin-bottom: calc(16px * 0.5);
}

.entity-icon i {
    display: inline-block;
}

.entity-info {
    flex: 1;
}

.entity-name {
    margin: 0 0 calc(16px * 0.5) 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
}

.entity-count {
    font-size: 1rem;
    color: #A51D35;
    font-weight: 600;
    margin-bottom: calc(16px * 0.5);
}

.entity-query-hint {
    font-size: 0.85rem;
    color: #8B1A2E;
    font-family: 'Courier New', monospace;
    background: rgba(165, 29, 53, 0.05);
    padding: calc(16px * 0.5);
    border-radius: 4px;
    word-break: break-all;
}

.entity-query-hint code {
    background: transparent;
    padding: 0;
}

.entity-search-btn {
    background: var(--entity-color, #A51D35);
    color: white;
    border: none;
    border-radius: 8px;
    padding: calc(16px * 0.75) 16px;
    cursor: pointer;
    font-weight: 500;
    transition: opacity 0.2s;
    margin-top: calc(16px * 0.5);
}

.entity-search-btn:hover {
    opacity: 0.9;
}

/* File Categories Section */
.file-categories-section {
    margin-bottom: calc(16px * 1.5);
    padding: 16px;
    background: linear-gradient(to bottom, #f9fafb, white);
    border-radius: 8px;
}

.file-categories-section h3 {
    font-size: 1.5rem;
    margin-bottom: calc(16px * 0.5);
    color: #1f2937;
}

.categories-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 16px;
    margin-top: 16px;
}

.category-card {
    background: white;
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border: 2px solid #e5e7eb;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    gap: calc(16px * 0.75);
}

.category-card:hover {
    border-color: var(--category-color, #D2691E);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
}

.category-icon {
    font-size: 2.5rem;
    margin-bottom: calc(16px * 0.5);
}

.category-icon i {
    display: inline-block;
}

.category-name {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
    color: #1f2937;
}

.category-browse-btn {
    background: var(--category-color, #D2691E);
    color: white;
    border: none;
    border-radius: 8px;
    padding: calc(16px * 0.75) 16px;
    cursor: pointer;
    font-weight: 500;
    transition: opacity 0.2s;
    width: 100%;
}

.category-browse-btn:hover {
    opacity: 0.9;
}

/* Search Capabilities Section */
.search-capabilities-section {
    margin-bottom: calc(16px * 1.5);
    padding: 16px;
    background: #f9fafb;
    border-radius: 8px;
    border: 1px solid #e5e7eb;
}

.search-capabilities-section h3 {
    font-size: 1.5rem;
    margin-bottom: calc(16px * 0.5);
    color: #1f2937;
}

.search-examples {
    margin-top: 16px;
}

.search-examples h4 {
    font-size: 1.1rem;
    margin-bottom: calc(16px * 0.5);
    color: #1f2937;
}

.search-examples-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.search-examples-list li {
    padding: calc(16px * 0.75);
    margin-bottom: calc(16px * 0.5);
    background: white;
    border-radius: 8px;
    border-left: 3px solid #D2691E;
}

.search-examples-list li strong {
    color: #8B4513;
    display: block;
    margin-bottom: calc(16px * 0.25);
}

.search-examples-list code {
    background: #f3f4f6;
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    color: #1f2937;
}

/* Removed insights and recommendations sections for static deployment */

/* Removed recommendations-grid for static deployment */

.insight-panel, .recommendation-box {
    background: white;
    border-radius: 12px;
    padding: 24px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    border: 1px solid #e5e7eb;
    border-left: 4px solid #D2691E;
    transition: all 0.3s ease;
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.insight-panel:hover, .recommendation-box:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    border-left-color: #8B4513;
}

.insight-header, .rec-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 16px;
    margin-bottom: 8px;
}

.insight-title, .rec-title {
    font-size: 1.3rem;
    font-weight: 600;
    color: #1f2937;
    margin: 0;
    flex: 1;
}

.insight-type, .rec-priority {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    padding: 6px 12px;
    border-radius: 20px;
    letter-spacing: 0.5px;
}

.rec-priority.priority-high {
    background: rgba(231, 76, 60, 0.15);
    color: #e74c3c;
    border: 1px solid #e74c3c;
}

.rec-priority.priority-medium {
    background: rgba(243, 156, 18, 0.15);
    color: #f39c12;
    border: 1px solid #f39c12;
}

.rec-priority.priority-low {
    background: rgba(52, 152, 219, 0.15);
    color: #3498db;
    border: 1px solid #3498db;
}

.insight-description, .rec-description {
    color: #4b5563;
    line-height: 1.6;
    font-size: 0.95rem;
    margin: 8px 0;
}

.insight-severity {
    font-size: 0.85rem;
    padding: 4px 10px;
    border-radius: 12px;
    display: inline-block;
    width: fit-content;
}

.severity-info {
    background: rgba(59, 130, 246, 0.1);
    color: #3b82f6;
}

.severity-warning {
    background: rgba(243, 156, 18, 0.1);
    color: #f39c12;
}

.severity-critical {
    background: rgba(231, 76, 60, 0.1);
    color: #e74c3c;
}

.rec-target-kpi {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px;
    background: #f3f4f6;
    border-radius: 8px;
    font-size: 0.9rem;
}

.kpi-label {
    font-weight: 600;
    color: #6b7280;
}

.kpi-value {
    color: #1f2937;
    font-weight: 500;
}

.rec-impact {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px;
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    border-radius: 8px;
}

.impact-badge {
    background: #f59e0b;
    color: white;
    padding: 4px 10px;
    border-radius: 12px;
    font-size: 0.85rem;
    font-weight: 600;
}

.impact-value {
    color: #92400e;
    font-weight: 600;
    font-size: 0.95rem;
}

.rec-timeline {
    display: flex;
    align-items: center;
    gap: 8px;
    color: #6b7280;
    font-size: 0.9rem;
    padding: 8px;
    background: #f9fafb;
    border-radius: 6px;
}

.timeline-icon {
    font-size: 1.1rem;
}

.rec-actions {
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid #e5e7eb;
}

.rec-actions ul {
    margin: 0;
    padding-left: 20px;
    list-style-type: disc;
}

.rec-actions li {
    margin: 8px 0;
    color: #4b5563;
    line-height: 1.5;
    font-size: 0.9rem;
}

.priority-badge {
    display: inline-block;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 15px;
}

.priority-badge.high {
    background: rgba(231, 76, 60, 0.15);
    color: #e74c3c;
    border: 1px solid #e74c3c;
}

.priority-badge.medium {
    background: rgba(243, 156, 18, 0.15);
    color: #f39c12;
    border: 1px solid #f39c12;
}

.priority-badge.low {
    background: rgba(52, 152, 219, 0.15);
    color: #3498db;
    border: 1px solid #3498db;
}

.action-button {
    background: #8B4513;
    color: white;
    border: none;
    border-radius: 8px;
    padding: 12px 24px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: 15px;
    display: inline-block;
}

.action-button:hover {
    background: #D2691E;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Responsive */
@media (max-width: 768px) {
    .dashboard-grid {
        padding: calc(16px * 0.5);
    }
    
    .entity-types-grid, .categories-grid {
        grid-template-columns: 1fr;
    }
    
    .metrics-grid {
        grid-template-columns: 1fr;
        gap: 16px;
    }
    
    .metric-card {
        padding: 20px;
        min-height: 180px;
    }
    
    .board-analyses-grid {
        grid-template-columns: 1fr;
        gap: 16px;
    }
    
    .board-analysis-card {
        padding: 20px;
    }
    
    .metric-value {
        font-size: 2rem;
        min-height: 2.5rem;
    }
    
    .metric-name {
        font-size: 0.8125rem;
    }
}

    </style>
</head>

<body>
    <!-- Dashboard Grid Layout -->
<div class="dashboard-grid">
    <header class="dashboard-header">
        <img src="https://mapsredmond.org/wp-content/uploads/2020/03/MapsLogoFinal_Full-logo-RedWhite.png" 
             alt="MAPS Logo" 
             class="maps-logo">
        <div class="header-content">
            <h1>Muslim Association of Puget Sound</h1>
            <p class="header-subtitle">Business Intelligence Dashboard</p>
        </div>
    </header>
    
    <main class="dashboard-main">
        <!-- Metrics Section -->
        <section class="metrics-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2 style="margin: 0;">üìä Key Metrics</h2>
                <select id="time-range-select" style="padding: 0.5rem; border-radius: 4px; border: 1px solid var(--control-border); background: var(--control-bg); color: var(--control-text); font-size: 0.9rem;">
                    <optgroup label="Current Periods">
                        <option value="today">Today</option>
                        <option value="this_week">This Week</option>
                        <option value="this_month">This Month</option>
                        <option value="this_quarter">This Quarter</option>
                        <option value="this_year" selected>This Year</option>
                    </optgroup>
                    <optgroup label="Previous Periods">
                        <option value="last_week">Last Week</option>
                        <option value="last_month">Last Month</option>
                        <option value="last_quarter">Last Quarter</option>
                        <option value="last_year">Last Year</option>
                    </optgroup>
                </select>
            </div>
            <div class="metrics-grid">

<div class="metric-card" data-metric-id="expenses_quickbooks">
    <div class="metric-header">
        <h3 class="metric-name">Expenses (QuickBooks)</h3>
        
    </div>
    <div class="metric-value">‚Äî</div>
    <div class="metric-target" style="display: none;"></div>
    
    <div class="metric-category">operations</div>
    
</div>

<div class="metric-card" data-metric-id="revenue_quickbooks">
    <div class="metric-header">
        <h3 class="metric-name">Revenue (QuickBooks)</h3>
        
    </div>
    <div class="metric-value">‚Äî</div>
    <div class="metric-target" style="display: none;"></div>
    
    <div class="metric-category">financial</div>
    
</div>

<div class="metric-card" data-metric-id="net_income_quickbooks">
    <div class="metric-header">
        <h3 class="metric-name">Net Income (QuickBooks)</h3>
        
    </div>
    <div class="metric-value">‚Äî</div>
    <div class="metric-target" style="display: none;"></div>
    <div id="profit-margin-display" style="font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.5rem; font-weight: 500;">‚Äî</div>
    
    <div class="metric-category">financial</div>
    
</div>

            </div>
        </section>
        
        <!-- Board Analyses Sections (moved up for better visibility) -->
        <!-- Revenue by Source -->
        <section id="revenue-by-source-section-container" style="margin-bottom: 0.5rem; display: none;">
            <div id="revenue-by-source-section" style="margin-bottom: 0;">
                <h3 style="font-size: 1.25em; margin-bottom: 0.75rem; color: var(--text-primary);">Revenue by Source</h3>
                <div id="revenue-sources-list" class="board-analyses-grid">
                    <!-- Revenue sources will be populated here -->
                </div>
                <div id="revenue-sources-chart" style="margin-top: 1.5rem; height: 300px; display: none;">
                    <!-- Chart will be rendered here -->
                </div>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <span style="color: #10b981;">‚úÖ</span> 100% Confidence - Business concepts (not source systems)
                </p>
            </div>
        </section>
        
        <!-- Expenses by Type -->
        <section id="expenses-by-type-section-container" style="margin-bottom: 0.5rem; display: none;">
            <div id="expenses-by-type-section" style="margin-bottom: 0;">
                <h3 style="font-size: 1.25em; margin-bottom: 0.75rem; color: var(--text-primary);">Expenses by Type</h3>
                <div id="expenses-by-type-list" class="board-analyses-grid">
                    <!-- Expense types will be populated here -->
                </div>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <span style="color: #10b981;">‚úÖ</span> 100% Confidence - Account-based calculation
                </p>
            </div>
        </section>
        
        <!-- Top Donors -->
        <section id="top-donors-section-container" style="margin-bottom: 0.5rem; display: none;">
            <div id="top-donors-section" style="margin-bottom: 0;">
                <h3 style="font-size: 1.25em; margin-bottom: 0.75rem; color: var(--text-primary);">Top Donors</h3>
                <div class="card" style="padding: 1.5rem;">
                    <div id="top-donors-list" style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color);">
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Donor</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Total</th>
                                    <th style="text-align: center; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Donations</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Avg</th>
                                    <th style="text-align: center; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Last Donation</th>
                                </tr>
                            </thead>
                            <tbody id="top-donors-tbody">
                                <tr>
                                    <td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <span style="color: #10b981;">‚úÖ</span> <span id="donor-coverage">96.7%</span> Confidence - <span id="donor-coverage-details">5,870 of 6,072 donations</span>
                </p>
            </div>
        </section>
        
        <!-- Programs -->
        <section id="programs-section-container" style="margin-bottom: 0.5rem; display: none;">
            <div id="programs-section" style="margin-bottom: 0;">
                <h3 style="font-size: 1.25em; margin-bottom: 0.75rem; color: var(--text-primary);">Programs</h3>
                <div id="programs-list" style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid var(--border-color);">
                                <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Program</th>
                                <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Revenue</th>
                                <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Expenses</th>
                                <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Net Income</th>
                                <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Profit Margin</th>
                            </tr>
                        </thead>
                        <tbody id="programs-tbody">
                            <tr>
                                <td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <span style="color: #f59e0b;">‚ö†Ô∏è</span> <span id="programs-coverage">Partial</span> Coverage - Only includes transactions with ClassRef assigned in QuickBooks
                </p>
            </div>
        </section>
        
        <!-- Funds -->
        <section id="funds-section-container" style="margin-bottom: 0.5rem; display: block;">
            <div id="funds-section" style="margin-bottom: 0;">
                <h3 style="font-size: 1.25em; margin-bottom: 0.75rem; color: var(--text-primary);">Funds</h3>
                <div class="card" style="padding: 1.5rem;">
                    <div id="funds-list" style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--border-color);">
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Fund Name</th>
                                    <th style="text-align: left; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Type</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Revenue</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Expenses</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Net</th>
                                    <th style="text-align: right; padding: 0.75rem; font-weight: 600; color: var(--text-primary);">Margin</th>
                                </tr>
                            </thead>
                            <tbody id="funds-tbody">
                                <tr>
                                    <td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-secondary);">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem;">
                    <span id="funds-coverage-indicator" style="color: #f59e0b;">‚ö†Ô∏è</span> <span id="funds-coverage">Partial</span> Coverage - <span id="funds-coverage-details">Only includes transactions with fund_id</span>
                    <br>
                    <span style="color: #10b981; font-size: 0.8rem;">‚úÖ Using JOINs to ensure only valid fund relationships are counted</span>
                </p>
            </div>
        </section>
        
        <!-- Insights Section -->
    </main>
</div>

    
    <script>
// Static deployment - cache mode only
const TENANT_ID = "maps";
const BUSINESS_TYPE = "non_profit_organization";

// Initialize Crema Client (cache mode only - no API)
const crema = new CremaClient(TENANT_ID, {
    mode: 'cache',
    cacheDir: 'data'
});

// Legacy categories (kept for backward compatibility, but will be replaced by Crema data)
const CREMA_CATEGORIES = [{"color":"#FF9500","count":6,"description":"Image files","icon":"photo","key":"image","mimeTypes":["image/jpeg","image/png","image/gif","image/webp","image/bmp","image/tiff","image/svg+xml"],"name":"Images","order":0,"schema":{"fields":["entity_type","file_name","file_path","file_size","file_type","mime_type"]}},{"color":"#34C759","count":9,"description":"Document files","icon":"doc.text","key":"document","mimeTypes":["application/pdf","application/msword","application/vnd.openxmlformats-officedocument.wordprocessingml.document","text/plain","application/rtf","application/vnd.oasis.opendocument.text"],"name":"Documents","order":1,"schema":{"fields":["entity_type","file_name","file_path","file_size","file_type","mime_type"]}},{"color":"#AF52DE","count":6,"description":"Video files","icon":"video","key":"video","mimeTypes":["video/mp4","video/quicktime","video/x-msvideo","video/x-ms-wmv","video/x-flv","video/x-matroska","video/webm"],"name":"Videos","order":2,"schema":{"fields":["entity_type","file_name","file_path","file_size","file_type","mime_type"]}},{"color":"#FF2D92","count":6,"description":"Audio files","icon":"music.note","key":"audio","mimeTypes":["audio/mpeg","audio/wav","audio/mp4","audio/flac","audio/aac","audio/ogg","audio/x-m4a"],"name":"Audio","order":3,"schema":{"fields":["entity_type","file_name","file_path","file_size","file_type","mime_type"]}},{"color":"#8E8E93","count":5,"description":"Binary files","icon":"gear","key":"binary","mimeTypes":["application/octet-stream","application/x-executable","application/x-msdownload","application/x-dmg","application/x-sharedlib"],"name":"Binary","order":5,"schema":{"fields":["author_name","file_dir","file_name","file_path","file_size","file_type","mime_type","place_id","place_name","rating","relative_time_description","text","time"]}}];
let CREMA_DATA = null;  // Store full Crema response (includes data_types from API)

// Fetch Crema data using CremaClient (replaces direct API call)
async function fetchCremaData() {
    try {
        console.log(`üîç Fetching Crema data (mode: ${crema.getMode()})`);
        
        // Use CremaClient to get Crema data
        CREMA_DATA = await crema.getCremaData();
        
        if (CREMA_DATA) {
            // Extract all entities from sources for backward compatibility
            const allEntities = (CREMA_DATA.sources || []).flatMap(s => s.entities || []);
            updateEntityCounts(allEntities);
            // Build entity schemas from Crema data (uses Crema's knowledge of entities)
            buildEntitySchemasFromCrema(CREMA_DATA);
            console.log('‚úÖ Crema data loaded successfully');
        } else {
            console.warn('‚ö†Ô∏è Crema data is null or empty');
        }
    } catch (error) {
        // Cache mode only: Crema data is optional - app can work without it
        console.warn('‚ö†Ô∏è Crema data not found in cache files (optional):', error.message);
        console.log('‚ÑπÔ∏è App will continue without Crema data. Some features may be limited.');
        CREMA_DATA = null;
    }
}

// REMOVED: Business views functionality
// All business views code has been removed - only Crema entities are displayed

// Calculate business-relevant metrics for each entity type
function calculateBusinessMetrics(entityType, records, totalCount) {
    if (!records || records.length === 0) return null;
    
    const entityLower = entityType.toLowerCase();
    const metrics = [];
    // Use totalCount if provided, otherwise fall back to records.length
    const recordCount = totalCount !== undefined && totalCount !== null ? totalCount : records.length;
    
    // Get all numeric fields
    const numericFields = {};
    records.forEach(record => {
        Object.keys(record).forEach(key => {
            const keyLower = key.toLowerCase();
            // Cleaned up system fields list - only essential fields
            const systemFieldsList = ['id', '_id', 'entity_type', 'source_system', 
                  'created_at', 'updated_at'];
            if (!systemFieldsList.includes(keyLower) &&
                !keyLower.startsWith('_')) {
                const value = record[key];
                if (typeof value === 'number' || (!isNaN(parseFloat(value)) && isFinite(value))) {
                    if (!numericFields[key]) {
                        numericFields[key] = [];
                    }
                    numericFields[key].push(parseFloat(value));
                }
            }
        });
    });
    
    // Generic business metrics - no hardcoded entity types
    // Dynamically detect field types and generate metrics based on what's present
    const entityLabel = entityName || entityType || 'Records';
    
    // Find all numeric fields and categorize them by type
    const fieldCategories = {
        amount: [],  // Financial amounts (amount, total, balance, cost, etc.)
        count: [],   // Counts (count, quantity, etc.)
        hours: [],   // Time-based (hours, time, etc.)
        other: []    // Other numeric fields
    };
    
    Object.keys(numericFields).forEach(fieldName => {
        const fieldLower = fieldName.toLowerCase();
        if (fieldLower.includes('amount') || fieldLower.includes('total') || 
            fieldLower.includes('balance') || fieldLower.includes('cost') || 
            fieldLower.includes('price') || fieldLower.includes('value') ||
            fieldLower.includes('budget') || fieldLower.includes('given') ||
            fieldLower.includes('requested') || fieldLower.includes('awarded')) {
            fieldCategories.amount.push(fieldName);
        } else if (fieldLower.includes('hour') || fieldLower.includes('time') || 
                   fieldLower.includes('duration')) {
            fieldCategories.hours.push(fieldName);
        } else if (fieldLower.includes('count') || fieldLower.includes('quantity')) {
            fieldCategories.count.push(fieldName);
        } else {
            fieldCategories.other.push(fieldName);
        }
    });
    
    // Generate financial metrics (amount fields)
    if (fieldCategories.amount.length > 0) {
        // Use the first amount field found (or combine if multiple)
        const primaryAmountField = fieldCategories.amount[0];
        const amounts = numericFields[primaryAmountField];
        const sum = amounts.reduce((a, b) => a + b, 0);
        const avg = sum / amounts.length;
        
        metrics.push({
            label: `Total ${entityLabel}`,
            value: `$${sum.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`,
            detail: `${recordCount} ${entityLabel.toLowerCase()}`,
            priority: 1
        });
        
        if (amounts.length > 1) {
            metrics.push({
                label: `Avg ${entityLabel}`,
                value: `$${avg.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`,
                detail: `Per ${entityLabel.toLowerCase()}`,
                priority: 2
            });
        }
    }
    
    // Generate time-based metrics (hours fields)
    if (fieldCategories.hours.length > 0) {
        const primaryHoursField = fieldCategories.hours[0];
        const hours = numericFields[primaryHoursField];
        const sum = hours.reduce((a, b) => a + b, 0);
        
        metrics.push({
            label: `Total Hours`,
            value: sum.toLocaleString(),
            detail: `${entityLabel.toLowerCase()}`,
            priority: fieldCategories.amount.length > 0 ? 3 : 1
        });
    }
    
    // Always include record count as a metric
    metrics.push({
        label: entityLabel,
        value: recordCount.toLocaleString(),
        detail: `Total ${entityLabel.toLowerCase()}`,
        priority: fieldCategories.amount.length > 0 ? (fieldCategories.hours.length > 0 ? 4 : 3) : 1
    });
    
    // All hardcoded entity type checks removed - metrics generated dynamically above
    
    // Sort by priority and return top 3
    return metrics.sort((a, b) => a.priority - b.priority).slice(0, 3);
}

// Load business insights for a tile
async function loadTileInsights(entityType, entityName, businessFields, totalCount) {
    const tileEl = document.getElementById(`tile-${entityType}`);
    if (!tileEl) return;
    
    const insightsEl = tileEl.querySelector('.tile-insights-content');
    if (!insightsEl) return;
    
    // Static mode: Entity insights not available
    return;
}

// Business entity analysis helper (defined globally)
window.quickAnalyze = function(records, fieldArray) {
    if (!records || records.length === 0) return null;
    
    const analysis = {
        total_records: records.length,
        top_values: {},
        numeric_fields: {},
        date_ranges: {},
        business_insights: []
    };
    
    // Analyze each field for business insights
    fieldArray.forEach(field => {
        const values = records.map(r => r[field]).filter(v => v !== null && v !== undefined && v !== '');
        if (values.length === 0) return;
        
        const fieldLower = field.toLowerCase();
        const coverage = (values.length / records.length * 100).toFixed(1);
        
        // Check if numeric (amounts, totals, balances, etc.)
        const numericValues = values.filter(v => typeof v === 'number' || (!isNaN(parseFloat(v)) && isFinite(v)));
        if (numericValues.length > 0) {
            const nums = numericValues.map(v => parseFloat(v));
            const stats = {
                min: Math.min(...nums),
                max: Math.max(...nums),
                avg: nums.reduce((a, b) => a + b, 0) / nums.length,
                sum: nums.reduce((a, b) => a + b, 0),
                count: nums.length
            };
            analysis.numeric_fields[field] = stats;
            
            // Business insights for financial fields
            if (fieldLower.includes('amount') || fieldLower.includes('total') || fieldLower.includes('balance') || 
                fieldLower.includes('price') || fieldLower.includes('cost') || fieldLower.includes('revenue')) {
                analysis.business_insights.push({
                    type: 'financial',
                    field: field,
                    label: field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    value: `$${stats.sum.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`,
                    detail: `Avg: $${stats.avg.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} | Range: $${stats.min.toLocaleString()} - $${stats.max.toLocaleString()}`,
                    coverage: coverage
                });
            } else if (fieldLower.includes('count') || fieldLower.includes('quantity') || fieldLower.includes('qty')) {
                analysis.business_insights.push({
                    type: 'count',
                    field: field,
                    label: field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                    value: stats.sum.toLocaleString(),
                    detail: `Avg: ${stats.avg.toFixed(1)} per record`,
                    coverage: coverage
                });
            }
        }
        
        // Check for date strings
        const dateValues = values.filter(v => typeof v === 'string' && /^\d{4}-\d{2}-\d{2}/.test(v));
        if (dateValues.length > 0) {
            const dates = dateValues.map(v => new Date(v)).filter(d => !isNaN(d.getTime()));
            if (dates.length > 0) {
                dates.sort((a, b) => a - b);
                const range = {
                    earliest: dates[0],
                    latest: dates[dates.length - 1],
                    span_days: Math.ceil((dates[dates.length - 1] - dates[0]) / (1000 * 60 * 60 * 24))
                };
                analysis.date_ranges[field] = range;
                
                // Business insights for date fields
                if (fieldLower.includes('date') || fieldLower.includes('time') || fieldLower.includes('created') || 
                    fieldLower.includes('updated') || fieldLower.includes('due')) {
                    analysis.business_insights.push({
                        type: 'date',
                        field: field,
                        label: field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        value: `${range.earliest.toLocaleDateString()} - ${range.latest.toLocaleDateString()}`,
                        detail: `${range.span_days} day span | ${dates.length} records`,
                        coverage: coverage
                    });
                }
            }
        }
        
        // Top unique values (for categorical/status fields)
        if (numericValues.length === 0 && dateValues.length === 0 && values.length > 0) {
            const valueCounts = {};
            values.forEach(v => {
                const key = String(v).substring(0, 100);
                valueCounts[key] = (valueCounts[key] || 0) + 1;
            });
            const sorted = Object.entries(valueCounts).sort((a, b) => b[1] - a[1]);
            
            if (sorted.length > 0) {
                analysis.top_values[field] = sorted.slice(0, 5);
                
                // Business insights for categorical fields (status, type, category, etc.)
                if (fieldLower.includes('status') || fieldLower.includes('state') || fieldLower.includes('type') || 
                    fieldLower.includes('category') || fieldLower.includes('class') || fieldLower.includes('priority')) {
                    const topValue = sorted[0];
                    const uniqueCount = sorted.length;
                    analysis.business_insights.push({
                        type: 'categorical',
                        field: field,
                        label: field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                        value: topValue[0],
                        detail: `${topValue[1]} records (${(topValue[1] / values.length * 100).toFixed(1)}%) | ${uniqueCount} unique values`,
                        coverage: coverage,
                        distribution: sorted.slice(0, 3).map(([val, count]) => ({value: val, count: count, pct: (count / values.length * 100).toFixed(1)}))
                    });
                } else if (fieldLower.includes('name') || fieldLower.includes('title') || fieldLower.includes('description')) {
                    // For name/title fields, show most common
                    if (sorted.length <= 10) {
                        analysis.business_insights.push({
                            type: 'text',
                            field: field,
                            label: field.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                            value: `${sorted.length} unique ${fieldLower.includes('name') ? 'names' : 'values'}`,
                            detail: `Most common: "${sorted[0][0].substring(0, 50)}" (${sorted[0][1]}x)`,
                            coverage: coverage
                        });
                    }
                }
            }
        }
    });
    
    // Sort insights by relevance (financial first, then dates, then categorical)
    analysis.business_insights.sort((a, b) => {
        const order = {financial: 0, date: 1, count: 2, categorical: 3, text: 4};
        return (order[a.type] || 99) - (order[b.type] || 99);
    });
    
    return analysis;
};

// Add click handler for entity data
window.showEntityData = async function(entityType, entityName) {
    // Static mode: Entity search not available
    return;
};

// Format field value for better readability (HTML version - different from plain text version below)
// NOTE: This is for HTML display, parameters are (value, fieldName)
window.formatFieldValueHTML = function(value, fieldName) {
        if (value === null || value === undefined || value === '') {
            return '<span style="color: #9ca3af; font-style: italic;">(empty)</span>';
        }
        
        // Handle objects/arrays
        if (typeof value === 'object') {
            if (Array.isArray(value)) {
                if (value.length === 0) return '<span style="color: #9ca3af;">(empty array)</span>';
                return value.map(item => {
                    if (typeof item === 'object') {
                        return JSON.stringify(item, null, 2);
                    }
                    return String(item);
                }).join(', ');
            }
            // Object - try to format nicely
            const keys = Object.keys(value);
            if (keys.length === 0) return '<span style="color: #9ca3af;">(empty object)</span>';
            if (keys.length <= 3) {
                // Small object - show as formatted name-value pairs
                return '<div style="display: flex; flex-direction: column; gap: 0.25rem;">' + 
                       keys.map(k => {
                           const v = window.formatFieldValueHTML(value[k], k);
                           return `<div style="display: flex; gap: 0.5rem;"><span style="font-weight: 600; color: #374151; min-width: fit-content;">${escapeHtml(k)}:</span><span style="color: #6b7280;">${v}</span></div>`;
                       }).join('') + 
                       '</div>';
            }
            // Large object - show as formatted JSON
            return '<pre style="margin: 0; font-size: 0.8rem; white-space: pre-wrap; word-break: break-word;">' + 
                   escapeHtml(JSON.stringify(value, null, 2)) + '</pre>';
        }
        
        // Handle strings
        if (typeof value === 'string') {
            // Check for date strings
            const datePattern = /^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/;
            if (datePattern.test(value)) {
                try {
                    const date = new Date(value);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
                } catch (e) {}
            }
            
            // Check for URLs
            if (value.startsWith('http://') || value.startsWith('https://')) {
                return `<a href="${escapeHtml(value)}" target="_blank" style="color: #007AFF; text-decoration: underline;">${escapeHtml(value)}</a>`;
            }
            
            // Check for email
            if (value.includes('@') && value.includes('.')) {
                return `<a href="mailto:${escapeHtml(value)}" style="color: #007AFF; text-decoration: underline;">${escapeHtml(value)}</a>`;
            }
            
            // Long strings - wrap but don't truncate
            return escapeHtml(value);
        }
        
        // Handle numbers
        if (typeof value === 'number') {
            // Format large numbers with commas
            if (fieldName && (fieldName.toLowerCase().includes('amount') || 
                             fieldName.toLowerCase().includes('balance') || 
                             fieldName.toLowerCase().includes('total') ||
                             fieldName.toLowerCase().includes('price') ||
                             fieldName.toLowerCase().includes('cost'))) {
                return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            }
            return value.toLocaleString('en-US');
        }
        
        // Handle booleans
        if (typeof value === 'boolean') {
            return value ? '<span style="color: #059669;">‚úì Yes</span>' : '<span style="color: #dc2626;">‚úó No</span>';
        }
        
    return escapeHtml(String(value));
};

// Show entity data modal
window.showEntityDataModal = async function(entityName, records, loading, errorMessage) {
        // Detect dark mode
        const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const bgColor = isDarkMode ? '#2d2d2d' : '#ffffff';
        const borderColor = isDarkMode ? '#404040' : '#e5e7eb';
        const textColor = isDarkMode ? '#e0e0e0' : '#111827';
        const textSecondary = isDarkMode ? '#b0b0b0' : '#6b7280';
        const buttonBg = isDarkMode ? '#3a3a3a' : '#f3f4f6';
        const buttonBgHover = isDarkMode ? '#4a4a4a' : '#e5e7eb';
        
        // Create or update modal
        let modal = document.getElementById('entity-data-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'entity-data-modal';
            modal.style.cssText = 'display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; overflow-y: auto;';
            modal.innerHTML = `
                <div style="max-width: 1400px; margin: 2rem auto; background: ${bgColor}; border-radius: 12px; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); min-height: 400px; color: ${textColor};">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 1.5rem; border-bottom: 1px solid ${borderColor};">
                        <h2 style="margin: 0; color: ${textColor}; font-size: 1.5rem;" id="modal-entity-name"></h2>
                        <button onclick="closeEntityDataModal()" style="background: ${buttonBg}; border: none; border-radius: 6px; padding: 0.5rem 1rem; cursor: pointer; font-size: 1.25rem; color: ${textSecondary};" onmouseover="this.style.background='${buttonBgHover}'" onmouseout="this.style.background='${buttonBg}'">√ó</button>
                    </div>
                    <div id="modal-content" style="padding: 1.5rem; overflow-x: auto; color: ${textColor};"></div>
                </div>
            `;
            document.body.appendChild(modal);
        } else {
            // Update existing modal colors if dark mode changed
            const modalContent = modal.querySelector('div[style*="max-width"]');
            if (modalContent) {
                modalContent.style.background = bgColor;
                modalContent.style.color = textColor;
                const header = modalContent.querySelector('div[style*="display: flex"]');
                if (header) {
                    header.style.borderBottomColor = borderColor;
                }
                const title = document.getElementById('modal-entity-name');
                if (title) {
                    title.style.color = textColor;
                }
                const closeBtn = header?.querySelector('button');
                if (closeBtn) {
                    closeBtn.style.background = buttonBg;
                    closeBtn.style.color = textSecondary;
                }
            }
        }
        
        // Update modal content
        document.getElementById('modal-entity-name').textContent = entityName;
        const content = document.getElementById('modal-content');
        
        if (loading) {
            const spinnerBorder = isDarkMode ? '#3a3a3a' : '#f3f4f6';
            const loadingTextColor = isDarkMode ? '#b0b0b0' : '#6b7280';
            content.innerHTML = `<div style="text-align: center; padding: 3rem;"><div style="display: inline-block; width: 40px; height: 40px; border: 4px solid ${spinnerBorder}; border-top-color: #3b82f6; border-radius: 50%; animation: spin 1s linear infinite;"></div><div style="margin-top: 1rem; color: ${loadingTextColor};">Loading entity data...</div></div><style>@keyframes spin { to { transform: rotate(360deg); } }</style>`;
            modal.style.display = 'block';
            modal.style.cursor = 'default';
            document.body.style.cursor = 'default';
            return;
        }
        
        if (errorMessage) {
            const errorColor = isDarkMode ? '#ef4444' : '#dc2626';
            content.innerHTML = `<div style="text-align: center; padding: 3rem; color: ${errorColor};">${escapeHtml(errorMessage)}</div>`;
            modal.style.display = 'block';
            modal.style.cursor = 'default';
            document.body.style.cursor = 'default';
            return;
        }
        
        if (!records || records.length === 0) {
            const emptyTextColor = isDarkMode ? '#b0b0b0' : '#6b7280';
            content.innerHTML = `<div style="text-align: center; padding: 3rem; color: ${emptyTextColor};">No records found</div>`;
            modal.style.display = 'block';
            modal.style.cursor = 'default';
            document.body.style.cursor = 'default';
            return;
        }
        
        // NO PROCESSING - Display data as-is from API
        // Collect fields ONLY from the records being displayed (validate they exist)
        const allFieldsSet = new Set();
        const fieldExistsInRecords = {}; // Track which fields exist in which records
        
        records.forEach((record, recordIndex) => {
            // Only collect top-level fields - do NOT extract from original_data
            // original_data will be shown as a single column with formatted JSON
            Object.keys(record).forEach(key => {
                allFieldsSet.add(key);
                if (!fieldExistsInRecords[key]) {
                    fieldExistsInRecords[key] = [];
                }
                fieldExistsInRecords[key].push(recordIndex);
            });
        });
        
        // Include ALL fields that exist in ANY record - no filtering, no sorting, no limits
        // Show fields exactly as they appear in the data (preserve insertion order)
        const allFields = Array.from(allFieldsSet);
        const displayRecords = records;
        
        window.currentEntityName = entityName;
        
        // Build table - simple, no processing
        const tableHeaderBg = isDarkMode ? '#1a1a1a' : '#f9fafb';
        const tableBorder = isDarkMode ? '#404040' : '#e5e7eb';
        const tableText = isDarkMode ? '#e0e0e0' : '#374151';
        const tableTextSecondary = isDarkMode ? '#b0b0b0' : '#6b7280';
        const tableTextPrimary = isDarkMode ? '#e0e0e0' : '#111827';
        
        let html = `<div style="margin-bottom: 1.5rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">`;
        html += `<div style="color: ${tableTextSecondary}; font-size: 0.875rem;">
            <span id="entity-record-count" style="font-weight: 600; color: ${tableTextPrimary};">${displayRecords.length}</span> record${displayRecords.length !== 1 ? 's' : ''} ‚Ä¢ 
            <span style="font-weight: 600; color: ${tableTextPrimary};">${allFields.length}</span> field${allFields.length !== 1 ? 's' : ''}
        </div>`;
        html += '</div>';
        
        html += `<div style="overflow-x: auto; border: 1px solid ${tableBorder}; border-radius: 8px;">`;
        html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
        
        // Table header - show all fields
        html += `<thead style="background: ${tableHeaderBg}; border-bottom: 2px solid ${tableBorder}; position: sticky; top: 0; z-index: 10;">`;
        html += '<tr>';
        html += `<th style="padding: 0.75rem 1rem; text-align: left; font-weight: 600; color: ${tableText}; border-right: 1px solid ${tableBorder}; min-width: 80px; max-width: 100px; position: sticky; left: 0; background: ${tableHeaderBg}; z-index: 11;">#</th>`;
        
        // Show all fields as-is
        allFields.forEach((field) => {
            html += `<th style="padding: 0.75rem 1rem; text-align: left; font-weight: 600; color: ${tableText}; border-right: 1px solid ${tableBorder}; min-width: 150px; max-width: 250px; vertical-align: top; word-break: break-word;">
                ${escapeHtml(field)}
            </th>`;
        });
        
        html += '</tr>';
        html += '</thead>';
        
        // Table body (records as rows)
        // Show ALL rows - NO FILTERING (filtering happens via filterEntityTable function)
        html += '<tbody id="entity-table-body">';
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        
        // Show all records - no limit message needed
        
        // Set initial HTML structure first (fast)
        content.innerHTML = html;
        modal.style.display = 'block';
        modal.style.cursor = 'default';
        document.body.style.cursor = 'default';
        
        // Render rows incrementally to prevent hiccups (defer heavy rendering)
        const tbody = document.getElementById('entity-table-body');
        if (tbody) {
            // Performance: Limit initial rendering to prevent hanging
            const MAX_INITIAL_ROWS = 100;
            const rowsToRender = displayRecords.slice(0, MAX_INITIAL_ROWS);
            const hasMoreRows = displayRecords.length > MAX_INITIAL_ROWS;
            
            // Use requestAnimationFrame to batch DOM updates and prevent blocking
            requestAnimationFrame(() => {
                const fragment = document.createDocumentFragment();
                rowsToRender.forEach((record, recordIndex) => {
                    const tr = document.createElement('tr');
                    tr.style.cssText = `border-bottom: 1px solid ${tableBorder};`;
                    
                    // Row number column (sticky)
                    const rowNumTd = document.createElement('td');
                    rowNumTd.style.cssText = `padding: 0.75rem 1rem; background: ${tableHeaderBg}; font-weight: 600; color: ${tableTextSecondary}; border-right: 1px solid ${tableBorder}; position: sticky; left: 0; z-index: 10; text-align: center;`;
                    rowNumTd.textContent = (recordIndex + 1).toString();
                    tr.appendChild(rowNumTd);
                    
                    // Render all fields as-is - only top-level fields (no extraction from original_data)
                    // original_data column gets special formatting for readability
                    allFields.forEach((field) => {
                        let value = record.hasOwnProperty(field) ? record[field] : null;
                        
                        // Special formatting for original_data column only
                        if (field === 'original_data' && value !== null && value !== undefined) {
                            const td = document.createElement('td');
                            td.style.cssText = `padding: 0.75rem 1rem; color: ${tableText}; border-right: 1px solid ${tableBorder}; font-family: 'Monaco', 'Menlo', 'Courier New', monospace; font-size: 0.75rem; line-height: 1.5; white-space: pre-wrap; word-break: break-word; max-width: 600px; background: ${isDarkMode ? '#0a0a0a' : '#f9fafb'};`;
                            td.textContent = JSON.stringify(value, null, 2);
                            tr.appendChild(td);
                            return; // Skip the default rendering for original_data
                        }
                        
                        // Render all other fields as-is - no formatting, no transformation
                        const td = document.createElement('td');
                        td.style.cssText = `padding: 0.75rem 1rem; border-right: 1px solid ${tableBorder}; vertical-align: top; word-wrap: break-word; word-break: break-word; white-space: normal; max-width: 250px; color: ${tableText};`;
                        
                        if (value === null) {
                            td.textContent = 'null';
                        } else if (value === undefined) {
                            td.textContent = 'undefined';
                        } else if (typeof value === 'object') {
                            // Show full JSON for objects (but not original_data - that's handled above)
                            td.textContent = JSON.stringify(value);
                        } else {
                            // Show raw value as string - no formatting
                            td.textContent = String(value);
                        }
                        tr.appendChild(td);
                    });
                    
                    fragment.appendChild(tr);
                });
                
                // Add message if more rows available
                if (hasMoreRows) {
                    const tr = document.createElement('tr');
                    const td = document.createElement('td');
                    td.colSpan = allFields.length + 1; // +1 for row number column
                    td.style.cssText = `padding: 1rem; text-align: center; color: ${tableTextSecondary}; background: ${tableHeaderBg};`;
                    td.textContent = `Showing ${rowsToRender.length} of ${displayRecords.length} records (${displayRecords.length - rowsToRender.length} more available)`;
                    tr.appendChild(td);
                    fragment.appendChild(tr);
                }
                
                // Batch append all rows at once
                tbody.appendChild(fragment);
            });
        }
};

// Close modal
window.closeEntityDataModal = function() {
    const modal = document.getElementById('entity-data-modal');
    if (modal) {
        modal.style.display = 'none';
    }
};

// Close modal on outside click
document.addEventListener('click', function(event) {
    const modal = document.getElementById('entity-data-modal');
    if (modal && event.target === modal) {
        closeEntityDataModal();
    }
});

// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Map SF Symbols to Font Awesome icons
function mapSFIconToFontAwesome(sfIcon) {
    if (!sfIcon) return 'fa-file';
    
    const iconMap = {
        // People icons
        'person.2': 'fa-users',
        'person.3': 'fa-users',
        'person.circle': 'fa-user-circle',
        'person.badge.plus': 'fa-user-plus',
        'person.crop.circle': 'fa-user-circle',
        'person.circle.fill': 'fa-user-circle',
        
        // Document icons
        'doc': 'fa-file',
        'doc.text': 'fa-file-alt',
        'doc.on.doc': 'fa-copy',
        'doc.text.fill': 'fa-file-alt',
        'doc.text.magnifyingglass': 'fa-file-search',
        'doc.richtext': 'fa-file-alt',
        
        // Money/finance icons
        'heart': 'fa-heart',
        'creditcard': 'fa-credit-card',
        'dollarsign.circle': 'fa-dollar-sign',
        'dollarsign.square': 'fa-dollar-sign',
        
        // Business icons
        'cart': 'fa-shopping-cart',
        'book': 'fa-book',
        'cube': 'fa-cube',
        'cube.box': 'fa-box',
        'folder': 'fa-folder',
        
        // System icons
        'clock': 'fa-clock',
        'gear': 'fa-cog',
        'list.bullet': 'fa-list',
        'square.and.pencil': 'fa-pencil-square',
        
        // Transport icons
        'truck.box': 'fa-truck',
        
        // Review/rating icons
        'star.bubble': 'fa-star',
        'star': 'fa-star',
        
        // Media icons (for categories)
        'photo': 'fa-image',
        'video': 'fa-video',
        'music.note': 'fa-music',
        'archivebox': 'fa-archive',
    };
    
    // Direct match
    if (iconMap[sfIcon]) {
        return iconMap[sfIcon];
    }
    
    // Try without dots (e.g., 'person.2' -> 'person')
    const baseIcon = sfIcon.split('.')[0];
    if (iconMap[baseIcon]) {
        return iconMap[baseIcon];
    }
    
    // Default fallback
    return 'fa-file';
}

// Error handling: Show user-visible error messages
function showError(message, section = 'general') {
    // Remove existing error in this section
    const existingError = document.querySelector(`.error-message[data-section="${section}"]`);
    if (existingError) {
        existingError.remove();
    }
    
    // Create error element
    const errorEl = document.createElement('div');
    errorEl.className = 'error-message';
    errorEl.setAttribute('data-section', section);
    errorEl.style.cssText = 'background: #dc2626; border: 2px solid #991b1b; padding: 1rem; border-radius: 8px; color: #ffffff; margin: 1rem 0; font-weight: 500;';
    errorEl.innerHTML = `<strong>‚ö†Ô∏è Error:</strong> <span style="color: #ffffff;">${escapeHtml(message)}</span>`;
    
    // Insert into appropriate section
    let sectionEl = null;
    if (section === 'metrics') {
        sectionEl = document.querySelector('.metrics-section') || document.querySelector('.metrics-grid');
    } else {
        sectionEl = document.querySelector('.dashboard-main');
    }
    
    // If section not found, don't try to insert (prevents errors)
    if (!sectionEl) {
        console.warn(`Section not found for error: ${section}`);
        return;
    }
    
    if (sectionEl) {
        sectionEl.insertBefore(errorEl, sectionEl.firstChild);
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            if (errorEl.parentNode) {
                errorEl.style.transition = 'opacity 0.5s';
                errorEl.style.opacity = '0';
                setTimeout(() => errorEl.remove(), 500);
            }
        }, 10000);
    } else {
        // Fallback: log to console
        console.error('‚ùå ' + message);
    }
}

// Loading state management
function showLoading(section) {
    const loadingId = `loading-${section}`;
    const existing = document.getElementById(loadingId);
    if (existing) return;
    
    const loadingEl = document.createElement('div');
    loadingEl.id = loadingId;
    loadingEl.className = 'loading-skeleton';
    loadingEl.style.cssText = 'padding: 2rem; text-align: center; cursor: wait;';
    loadingEl.innerHTML = '';
    
    let sectionEl = null;
    // Removed insights and recommendations sections for static deployment
    if (false) { // Disabled for static deployment
        // Insights and recommendations not available
    } else if (section === 'metrics') {
        // For metrics, insert loading message after the metrics-grid (below it)
        // This prevents the loading message from causing the metrics grid to resize
        sectionEl = document.querySelector('.metrics-section');
        if (sectionEl) {
            sectionEl.style.cursor = 'wait';
            // Append to metrics-section, which will place it after metrics-grid
            sectionEl.appendChild(loadingEl);
        } else {
            // Fallback: try to find metrics-grid and append after it
            const metricsGrid = document.querySelector('.metrics-grid');
            if (metricsGrid && metricsGrid.parentNode) {
                metricsGrid.parentNode.insertBefore(loadingEl, metricsGrid.nextSibling);
            }
        }
    }
}

function hideLoading(section) {
    const loadingId = `loading-${section}`;
    const loadingEl = document.getElementById(loadingId);
    if (loadingEl) {
        loadingEl.remove();
    }
    
    // Reset cursor on section
    let sectionEl = null;
    // Removed insights and recommendations sections for static deployment
    if (section === 'metrics') {
        sectionEl = document.querySelector('.metrics-section');
    }
    
    if (sectionEl) {
        sectionEl.style.cursor = 'default';
    }
}

// Data validation for standardized API responses
function validateResponse(result, endpoint) {
    if (!result || typeof result !== 'object') {
        return { valid: false, error: `Invalid response: not an object` };
    }
    
    if (!result.success) {
        return { valid: false, error: result.error || 'Request failed' };
    }
    
    if (!result.data || typeof result.data !== 'object') {
        return { valid: false, error: `Invalid response: missing data field` };
    }
    
    // Endpoint-specific validation
    if (endpoint === 'insights' && !result.data.insights) {
        return { valid: false, error: `Invalid insights response: missing insights field` };
    }
    
    if (endpoint === 'metrics' && !result.data.metrics) {
        return { valid: false, error: `Invalid metrics response: missing metrics field` };
    }
    
    if (endpoint === 'recommendations' && !result.data.recommendations) {
        return { valid: false, error: `Invalid recommendations response: missing recommendations field` };
    }
    
    return { valid: true };
}

// Calculate data quality statistics for an entity
function calculateDataQualityMetrics(records) {
    if (!records || records.length === 0) return null;
    
    const totalRecords = records.length;
    const fieldStats = {};
    
    // Collect all unique fields across all records (NO FILTERING - show all fields)
    // Format: record.original_data contains business fields, top-level fields contain system fields
    // Use Map to preserve insertion order and ensure deterministic field processing
    const allFieldsMap = new Map();
    records.forEach(record => {
        // Fail fast: Must have original_data
        if (!record.original_data) {
            console.error(`‚ùå Record missing required structure in calculateDataQualityMetrics:`, record);
            return;
        }
        
        // Collect business fields from original_data
        const originalDataKeys = Object.keys(record.original_data || {}).sort();
        originalDataKeys.forEach(key => {
            if (!allFieldsMap.has(key)) {
                allFieldsMap.set(key, { source: 'original_data' });
            }
        });
        // Collect system fields from top level (id, data_type, created_at, etc.)
        Object.keys(record).forEach(key => {
            if (key !== 'original_data' && !allFieldsMap.has(key)) {
                allFieldsMap.set(key, { source: 'top_level' });
            }
        });
    });
    
    // Convert to sorted array for deterministic processing
    const allFields = Array.from(allFieldsMap.keys()).sort();
    
    // Calculate statistics for each field (in sorted order for determinism)
    allFields.forEach(field => {
        // Get all values for this field across all records
        // Check original_data or top level based on field source (fail fast - no fallback)
        const allValues = records.map(r => {
            // Fail fast: Must have original_data
            if (!r.original_data) {
                console.error(`‚ùå Record missing required structure in calculateDataQualityMetrics:`, r);
                return null;
            }
            
            const fieldInfo = allFieldsMap.get(field);
            if (fieldInfo) {
                if (fieldInfo.source === 'original_data') {
                    return r.original_data[field];
                } else if (fieldInfo.source === 'top_level') {
                    return r[field];
                }
            }
            // Field not found in either source - return null
            return null;
        });
        
        // Count different value states
        const nonNullValues = allValues.filter(v => v !== null && v !== undefined && v !== '');
        const nonNullCount = nonNullValues.length;
        const emptyStringCount = allValues.filter(v => v === '').length;
        const nullCount = allValues.filter(v => v === null || v === undefined).length;
        
        // Completeness = (non-null + empty strings) / total
        // Empty strings indicate the field exists but is empty, so they count toward completeness
        const completeness = ((nonNullCount + emptyStringCount) / totalRecords * 100).toFixed(1);
        
        // Check for data types (only on non-null, non-empty values)
        const numericCount = nonNullValues.filter(v => typeof v === 'number' || (!isNaN(parseFloat(v)) && isFinite(v))).length;
        const stringCount = nonNullValues.filter(v => typeof v === 'string').length;
        const booleanCount = nonNullValues.filter(v => typeof v === 'boolean').length;
        const objectCount = nonNullValues.filter(v => typeof v === 'object' && v !== null && !Array.isArray(v)).length;
        const arrayCount = nonNullValues.filter(v => Array.isArray(v)).length;
        
        fieldStats[field] = {
            completeness: parseFloat(completeness),
            nonNullCount: nonNullCount,
            emptyStringCount: emptyStringCount,
            nullCount: nullCount,
            numericCount: numericCount,
            stringCount: stringCount,
            booleanCount: booleanCount,
            objectCount: objectCount,
            arrayCount: arrayCount
        };
    });
    
    // Calculate overall metrics
    const fieldsWithData = Object.keys(fieldStats).length;
    
    // Handle case when no fields with data are found (all filtered out)
    if (fieldsWithData === 0) {
        return {
            totalRecords: totalRecords,
            totalFields: 0,
            avgCompleteness: '0.0',
            fullyCompleteFields: 0,
            partiallyCompleteFields: 0,
            emptyFields: 0,
            fieldStats: {}
        };
    }
    
    const avgCompleteness = Object.values(fieldStats).reduce((sum, stat) => sum + stat.completeness, 0) / fieldsWithData;
    const fullyCompleteFields = Object.values(fieldStats).filter(stat => stat.completeness === 100).length;
    const partiallyCompleteFields = Object.values(fieldStats).filter(stat => stat.completeness > 0 && stat.completeness < 100).length;
    const emptyFields = Object.values(fieldStats).filter(stat => stat.completeness === 0).length;
    
    return {
        totalRecords: totalRecords,
        totalFields: fieldsWithData,
        avgCompleteness: avgCompleteness.toFixed(1),
        fullyCompleteFields: fullyCompleteFields,
        partiallyCompleteFields: partiallyCompleteFields,
        emptyFields: emptyFields,
        fieldStats: fieldStats
    };
}

// Load data quality insights for a Crema entity tile
async function loadCremaEntityQualityInsights(entityType, entityName) {
    const tileEl = document.getElementById(`crema-tile-${entityType}`);
    if (!tileEl) return;
    
    const insightsEl = tileEl.querySelector('.tile-insights-content');
    if (!insightsEl) return;
    
    // Static mode: Entity quality insights not available
    return;
}

// Entity schema definitions - built dynamically from Crema data
// Crema provides entity type information, and we use it to determine field structures
let ENTITY_SCHEMAS = {};

// Build entity schemas from Crema data
function buildEntitySchemasFromCrema(cremaData) {
    if (!cremaData || !cremaData.data_types) return;
    
    // Default exclude fields (system fields that should not be displayed)
    const defaultExcludeFields = ['business_id', 'source', 'source_system', 'created_at', 'updated_at', 'timestamp'];
    
    ENTITY_SCHEMAS = {};
    
    // Build schemas for each entity type from Crema
    cremaData.data_types.forEach(entityType => {
        const key = entityType.data_type || entityType.key || '';
        if (!key) return;
        
        const normalizedKey = key.toLowerCase();
        const category = entityType.category || '';
        
        // Require schema from Crema - fail fast if not available
        if (!entityType.schema || !entityType.schema.fields || !Array.isArray(entityType.schema.fields)) {
            // Skip this entity type - don't register it in ENTITY_SCHEMAS
            return;
        }
        
        const cremaFields = entityType.schema.fields;
        
        // Build schema from Crema fields (data-driven)
        const headerFields = {};
        const importantFields = [];
        
        // Identify header fields (name, amount, status) from available fields
        // Handle both camelCase (QuickBooks) and snake_case field names
        // Prioritize actual name fields over IDs
        const nameFields = cremaFields.filter(f => {
            const fLower = f.toLowerCase();
            return ['name', 'donor_name', 'customer_name', 'title', 'display_name', 'firstname', 'lastname', 'givenname', 'familyname', 'fullyqualifiedname'].some(match => fLower.includes(match.toLowerCase()));
        });
        
        // Also check for ID fields separately (lower priority)
        const idFields = cremaFields.filter(f => {
            const fLower = f.toLowerCase();
            return fLower === 'id' || fLower.endsWith('_id');
        });
        
        // Prefer actual name fields over IDs
        // Priority: DisplayName/name > firstname/lastname > title > ID fields
        const sortedNameFields = nameFields.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();
            // Highest priority: DisplayName, name
            if (aLower === 'displayname' || aLower === 'name') return -1;
            if (bLower === 'displayname' || bLower === 'name') return 1;
            // Second priority: firstname, lastname, givenname, familyname
            if (['firstname', 'lastname', 'givenname', 'familyname'].includes(aLower)) return -1;
            if (['firstname', 'lastname', 'givenname', 'familyname'].includes(bLower)) return 1;
            // Third priority: title, donor_name, customer_name
            if (['title', 'donor_name', 'customer_name'].includes(aLower)) return -1;
            if (['title', 'donor_name', 'customer_name'].includes(bLower)) return 1;
            return 0;
        });
        
        // Use name fields only (fail fast - no ID fallback)
        // If no name fields exist, schema will not have a name field (fail fast)
        if (sortedNameFields.length > 0) {
            headerFields.name = sortedNameFields.slice(0, 3);
        }
        // Fail fast: if no name fields found, don't add name to headerFields (no ID fallback)
        
        const amountFields = cremaFields.filter(f => {
            const fLower = f.toLowerCase();
            return ['amount', 'total', 'price', 'balance', 'total_amount', 'donation_amount', 'payment_amount', 'total_donated', 'lifetime_value', 'revenue', 'cost', 'fee', 'currentbalance', 'purchasecost', 'unitprice'].some(match => fLower.includes(match.toLowerCase()));
        });
        // Prefer 'balance' or 'amount' fields for financial entities
        const sortedAmountFields = amountFields.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();
            if (aLower.includes('balance') && !bLower.includes('balance')) return -1;
            if (bLower.includes('balance') && !aLower.includes('balance')) return 1;
            if (aLower.includes('amount') && !bLower.includes('amount')) return -1;
            if (bLower.includes('amount') && !aLower.includes('amount')) return 1;
            return 0;
        });
        if (sortedAmountFields.length > 0) {
            headerFields.amount = sortedAmountFields.slice(0, 3);
        }
        
        const statusFields = cremaFields.filter(f => {
            const fLower = f.toLowerCase();
            return ['status', 'type', 'donation_type', 'donor_type', 'payment_status', 'accounttype', 'accountsubtype'].some(match => fLower.includes(match.toLowerCase()));
        });
        // Prefer 'Type' or 'type' over 'AccountType' for consistency
        const sortedStatusFields = statusFields.sort((a, b) => {
            const aLower = a.toLowerCase();
            const bLower = b.toLowerCase();
            if (aLower === 'type') return -1;
            if (bLower === 'type') return 1;
            return 0;
        });
        if (sortedStatusFields.length > 0) {
            headerFields.status = sortedStatusFields.slice(0, 2);
        }
        
        // Identify important fields (dates, IDs, contact info)
        const importantFieldPatterns = ['date', 'id', 'email', 'phone', 'donor_id', 'program_id', 'payment_method', 'tax_deductible'];
        cremaFields.forEach(field => {
            if (importantFieldPatterns.some(pattern => field.toLowerCase().includes(pattern.toLowerCase()))) {
                importantFields.push(field);
            }
        });
        
        // Require at least one header field to be identified from schema
        if (Object.keys(headerFields).length === 0) {
            console.error('‚ùå No header fields identified for entity type "' + key + '" from Crema schema fields: ' + cremaFields.join(', '));
            // Skip this entity type - don't register it
            return;
        }
        
        const schema = {
            headerFields: headerFields,
            importantFields: importantFields.slice(0, 10), // Limit to top 10 important fields
            fields: cremaFields  // Schema defines all business fields
        };
        
        ENTITY_SCHEMAS[normalizedKey] = schema;
        
        // Also map aliases if present
        if (entityType.aliases && Array.isArray(entityType.aliases)) {
            entityType.aliases.forEach(alias => {
                const normalizedAlias = alias.toLowerCase();
                if (!ENTITY_SCHEMAS[normalizedAlias]) {
                    ENTITY_SCHEMAS[normalizedAlias] = schema;
                }
            });
        }
    });
    
    // Also build schemas for file categories if provided by Crema as entityTypes
    // File types (image, document, video, audio) should be included in entityTypes with schemas
    // OR categories should have schemas - check both
    // Process categories only if they have schemas (data-driven, no hardcoding)
    if (cremaData.categories && Array.isArray(cremaData.categories)) {
        cremaData.categories.forEach(category => {
            const categoryKey = category.key || category.category || '';
            if (!categoryKey) return;
            
            const normalizedKey = categoryKey.toLowerCase();
            
            // Only process if this category has a schema from Crema (data-driven)
            if (category.schema && category.schema.fields && Array.isArray(category.schema.fields)) {
                const cremaFields = category.schema.fields;
                
                // Build schema from Crema fields (data-driven, same as entity types)
                const headerFields = {};
                const importantFields = [];
                
                // Identify header fields from actual Crema-provided fields (no hardcoding)
                const nameFields = cremaFields.filter(f => ['file_name', 'fileName', 'name', 'title'].some(match => f.toLowerCase().includes(match.toLowerCase())));
                if (nameFields.length > 0) {
                    headerFields.name = nameFields.slice(0, 3);
                }
                
                const statusFields = cremaFields.filter(f => ['mime_type', 'mimeType', 'file_type', 'fileType', 'type'].some(match => f.toLowerCase().includes(match.toLowerCase())));
                if (statusFields.length > 0) {
                    headerFields.status = statusFields.slice(0, 2);
                }
                
                // Identify important fields from actual Crema-provided fields
                const importantFieldPatterns = ['file_path', 'filePath', 'file_size', 'fileSize', 'created_at', 'updated_at', 'modified_at'];
                cremaFields.forEach(field => {
                    if (importantFieldPatterns.some(pattern => field.toLowerCase().includes(pattern.toLowerCase()))) {
                        importantFields.push(field);
                    }
                });
                
                // Require at least one header field to be identified from schema
                if (Object.keys(headerFields).length > 0) {
                    const schema = {
                        headerFields: headerFields,
                        importantFields: importantFields.slice(0, 10),
                        excludeFields: defaultExcludeFields
                    };
                    
                    ENTITY_SCHEMAS[normalizedKey] = schema;
                }
            }
        });
    }
}

// Get schema for entity type (requires Crema-based schemas - fail fast)
function getEntitySchemaForType(entityType) {
    if (!entityType) {
        console.error('‚ùå Entity type is required for schema lookup');
        throw new Error('Entity type is required for schema lookup');
    }
    const normalizedType = String(entityType).toLowerCase().replace(/[^a-z0-9_]/g, '');
    const schema = ENTITY_SCHEMAS[normalizedType];
    
    if (!schema) {
        const errorMsg = '‚ùå Schema not found for entity type "' + entityType + '" (normalized: "' + normalizedType + '"). Schema must be provided by Crema. Available schemas: ' + Object.keys(ENTITY_SCHEMAS).join(', ') + '. Please ensure Crema analyzes ' + entityType + ' data and provides schema.fields.';
        console.error(errorMsg);
        throw new Error(errorMsg);
    }
    return schema;
}

// Format date/time values for human readability
function formatDateValue(value) {
    if (!value) return '';
    
    // If it's already a formatted string (has spaces, dashes, etc.), return as-is
    if (typeof value === 'string' && (value.includes('-') || value.includes('/') || value.includes(' ') || value.toLowerCase().includes('ago'))) {
        return value;
    }
    
    // Try to parse as Unix timestamp (seconds or milliseconds)
    let timestamp = typeof value === 'string' ? parseFloat(value) : Number(value);
    
    // If it's a valid number, try to format as date
    if (!isNaN(timestamp) && timestamp > 0) {
        // Handle both seconds and milliseconds
        if (timestamp < 10000000000) {
            timestamp = timestamp * 1000; // Convert seconds to milliseconds
        }
        
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
            // Format as: "Nov 2, 2025 at 8:45 PM" or relative time if recent
            const now = new Date();
            const diffMs = now - date;
            const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            
            if (diffDays === 0) {
                return 'Today at ' + date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            } else if (diffDays === 1) {
                return 'Yesterday at ' + date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            } else if (diffDays < 7) {
                return diffDays + ' days ago';
            } else if (diffDays < 30) {
                const weeks = Math.floor(diffDays / 7);
                return weeks === 1 ? '1 week ago' : weeks + ' weeks ago';
            } else if (diffDays < 365) {
                const months = Math.floor(diffDays / 30);
                return months === 1 ? '1 month ago' : months + ' months ago';
            } else {
                return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
            }
        }
    }
    
    return String(value);
}

// Format field labels - return as-is (no transformation)
function formatFieldLabel(key) {
    // Return original field name without any transformation
    return key;
}

// Format field values based on field type
function formatFieldValue(key, value) {
    if (value === null || value === undefined || value === '') {
        return '(empty)';
    }
    
    // Handle date/time fields
    if (key.toLowerCase().includes('time') || key.toLowerCase().includes('date') || key === 'fetched_at' || key === 'time') {
        return formatDateValue(value);
    }
    
    // Handle currency/money fields - format as dollar amounts
    const currencyFields = ['amount', 'total', 'price', 'balance', 'total_amount', 'donation_amount', 'payment_amount', 
                           'total_donated', 'lifetime_value', 'revenue', 'expense_amount', 'cost', 'fee'];
    if (currencyFields.some(field => key.toLowerCase().includes(field))) {
        const numValue = typeof value === 'string' ? parseFloat(value) : Number(value);
        if (!isNaN(numValue)) {
            return '$' + Math.round(numValue).toLocaleString('en-US');
        }
    }
    
    // Handle rating - show as stars
    if (key.toLowerCase() === 'rating') {
        const rating = typeof value === 'string' ? parseFloat(value) : Number(value);
        if (!isNaN(rating) && rating >= 0 && rating <= 5) {
            const stars = '‚≠ê'.repeat(Math.round(rating));
            return stars + ' ' + rating + '/5';
        }
    }
    
    // Handle numbers - format with commas
    if (typeof value === 'number') {
        return value.toLocaleString('en-US');
    }
    
    // Handle booleans (both boolean true/false and string "true"/"false")
    if (typeof value === 'boolean') {
        return value ? 'Yes' : 'No';
    }
    if (typeof value === 'string' && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        return value.toLowerCase() === 'true' ? 'Yes' : 'No';
    }
    
    // Handle objects/arrays - should not reach here as formatValue handles these
    if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
    }
    
    // Return string value as-is (will be escaped when displayed)
    return String(value);
}

// REMOVED: extractEntityFields function - no longer used
// Fields are now displayed directly from originalData without extraction
function extractEntityFields_DEPRECATED(originalData, metadata, result, schema) {
    // Helper: Get all header field names for exclusion from body (to avoid duplication)
    function getHeaderFieldNames(schema) {
        const names = new Set(['source', 'source_entity_type', 'source_system']);
        if (schema.headerFields) {
            Object.values(schema.headerFields).forEach(fieldNames => {
                if (Array.isArray(fieldNames)) {
                    fieldNames.forEach(name => names.add(name));
                }
            });
        }
        return Array.from(names);
    }
    
    // Helper: Check if field is numeric
    function isNumericField(fieldType, fieldNames) {
        const numericTypes = ['amount', 'total', 'price', 'balance', 'cost', 'fee', 'revenue', 'expense_amount', 'quantity', 'count'];
        const numericPatterns = ['amount', 'total', 'price', 'balance', 'cost', 'fee', 'revenue', 'expense', 'quantity', 'count', 'value'];
        return numericTypes.includes(fieldType) || 
               numericPatterns.some(pattern => fieldNames.some(fn => fn.toLowerCase().includes(pattern)));
    }
    
    // Helper: Format value based on field type
    function formatValue(key, value) {
        // Handle null/undefined
        if (value == null || value === undefined) return '(not set)';
        
        // Handle empty strings - show as indicator that field exists but is empty
        if (value === '') return '(empty)';
        
        // Handle arrays
        if (Array.isArray(value)) {
            if (value.length === 0) return '(empty array)';
            
            // Format array items
            return value.map((v, idx) => {
                if (typeof v === 'object' && v !== null) {
                    // Format nested objects in array
                    return formatNestedObject(v, 1);
                }
                // Use formatFieldValue for non-object values to get proper formatting
                return formatFieldValue(key, v);
            }).join(', ');
        }
        
        // Handle objects
        if (typeof value === 'object') {
            return formatNestedObject(value, 0);
        }
        
        // For primitive values, use formatFieldValue to get proper formatting (dates, currency, etc.)
        return formatFieldValue(key, value);
    }
    
    // Helper function to format nested objects in a readable way
    function formatNestedObject(obj, indentLevel = 0) {
        if (!obj || typeof obj !== 'object') return String(obj);
        
        const indent = '  '.repeat(indentLevel);
        const lines = [];
        
        // Handle common QuickBooks nested structures
        // Ref objects (e.g., {value: "123", name: "Account Name"})
        if (obj.value !== undefined && obj.name !== undefined && Object.keys(obj).length <= 3) {
            return `${obj.name || obj.value} (${obj.value})`;
        }
        
        // MetaData objects (e.g., {CreateTime: "...", LastUpdatedTime: "..."})
        if (obj.CreateTime || obj.LastUpdatedTime || obj.LastModifiedTime) {
            const parts = [];
            if (obj.CreateTime) parts.push(`Created: ${formatDateValue(obj.CreateTime)}`);
            if (obj.LastUpdatedTime) parts.push(`Updated: ${formatDateValue(obj.LastUpdatedTime)}`);
            if (obj.LastModifiedTime) parts.push(`Modified: ${formatDateValue(obj.LastModifiedTime)}`);
            return parts.join(', ');
        }
        
        // CurrencyRef objects (e.g., {value: "USD", name: "United States Dollar"})
        // Note: key is not available here, but we can detect by structure
        if (obj.value && obj.name && Object.keys(obj).length <= 3) {
            // Likely a reference object (Ref, CurrencyRef, etc.)
            return `${obj.name} (${obj.value})`;
        }
        
        // Simple objects with 2-3 fields - format inline
        const keys = Object.keys(obj);
        if (keys.length <= 3) {
            const parts = keys.map(k => {
                const v = obj[k];
                if (typeof v === 'object' && v !== null) {
                    return `${k}: ${formatNestedObject(v, indentLevel + 1)}`;
                }
                // Format primitive values properly (dates, numbers, etc.)
                // Use a dummy key to check if it's a date/number field
                const formatted = formatFieldValue(k, v);
                return `${k}: ${formatted}`;
            });
            return '{ ' + parts.join(', ') + ' }';
        }
        
        // Complex objects - format with indentation
        keys.forEach(k => {
            const v = obj[k];
            if (typeof v === 'object' && v !== null && !Array.isArray(v)) {
                lines.push(`${indent}${k}:`);
                lines.push(formatNestedObject(v, indentLevel + 1));
            } else if (Array.isArray(v)) {
                lines.push(`${indent}${k}: [${v.length} items]`);
                if (v.length > 0 && v.length <= 5) {
                    v.forEach((item, idx) => {
                        if (typeof item === 'object') {
                            lines.push(`${indent}  [${idx}]: ${formatNestedObject(item, indentLevel + 2)}`);
                        } else {
                            lines.push(`${indent}  [${idx}]: ${item}`);
                        }
                    });
                }
            } else {
                lines.push(`${indent}${k}: ${v}`);
            }
        });
        
        const result = lines.join('\n');
        // If result is too long, truncate
        if (result.length > 500) {
            return result.substring(0, 500) + '\n... (truncated)';
        }
        return result;
    }
    
    // Step 1: API now returns only original_data directly as the result
    // originalData IS the result (no need to combine multiple sources)
    // Use originalData directly (it contains all the business data from the source system)
    
    // Step 2: Extract header fields (only from originalData)
    const header = {};
    if (schema.headerFields) {
        Object.keys(schema.headerFields).forEach(fieldType => {
            const fieldNames = schema.headerFields[fieldType];
            if (fieldNames && Array.isArray(fieldNames)) {
                // Special handling for name field: use firstname/lastname if available (fail-fast, no ID fallback)
                if (fieldType === 'name') {
                    // Check if we have firstname/lastname
                    const firstname = originalData.firstname || originalData.firstName || originalData.GivenName || originalData.givenname;
                    const lastname = originalData.lastname || originalData.lastName || originalData.FamilyName || originalData.familyname;
                    
                    // Use available name fields (firstname, lastname, or both)
                    if (firstname && lastname) {
                        // Combine firstname and lastname
                        header[fieldType] = `${firstname} ${lastname}`;
                    } else if (firstname) {
                        // Use firstname if available
                        header[fieldType] = firstname;
                    } else if (lastname) {
                        // Use lastname if available
                        header[fieldType] = lastname;
                    } else {
                        // Fail-fast: if no firstname/lastname available, set to null (no ID or other field fallback)
                        header[fieldType] = null;
                    }
                } else {
                    // Regular field extraction for non-name fields
                let value = null;
                for (const fieldName of fieldNames) {
                    // Try exact match first
                    value = originalData[fieldName];
                    if (value != null && value !== '') break;
                    
                    // Try case-insensitive match if exact match failed
                    if (value == null || value === '') {
                        const dataKeys = Object.keys(originalData);
                        const matchingKey = dataKeys.find(key => key.toLowerCase() === fieldName.toLowerCase());
                        if (matchingKey) {
                            value = originalData[matchingKey];
                            if (value != null && value !== '') break;
                        }
                    }
                }
                
                // Convert numeric fields to numbers
                if (value != null && isNumericField(fieldType, fieldNames) && typeof value === 'string') {
                    const num = parseFloat(value);
                    if (!isNaN(num)) value = num;
                }
                
                header[fieldType] = value;
                }
            }
        });
    }
    
    // Source is now in mapping table - not in originalData or metadata
    // Will be retrieved via JOIN to source_entity_mappings table
    header.source = null;  // No fallback - use mapping table
    
    // Step 3: Extract body fields - show business fields from originalData (exclude system fields)
    // Use same filtering as calculateDataQualityMetrics for consistency
    const fieldsToShow = [];
    
    // Iterate through fields from originalData
    // All fields in originalData are business fields by definition
    // System fields are at top level but not in original_data - we don't need to check here
    Object.keys(originalData || {}).forEach(key => {
        const keyLower = key.toLowerCase();
        
        // Exclude fields starting with underscore (internal use)
        if (keyLower.startsWith('_')) {
            return; // Skip this field
        }
        
        const value = originalData[key];
        
        // Only skip if truly null/undefined (field doesn't exist)
        // Show all other values including empty strings, nulls, etc.
        if (value === null || value === undefined) {
            fieldsToShow.push({
                label: formatFieldLabel(key),
                value: '(null)'
            });
            return;
        }
        
        // Show business fields only (system fields already excluded above)
        const formattedLabel = formatFieldLabel(key);
        const formattedValue = formatValue(key, value);
        
            fieldsToShow.push({
                key: key,  // Store original key for source field detection
                label: formattedLabel,
                value: formattedValue
            });
    });
    
    return { header, fieldsToShow };
}

// Results modal functions
function showResultsModal(title, results) {
    const modal = document.getElementById('results-modal');
    const titleEl = document.getElementById('results-modal-title');
    const contentEl = document.getElementById('results-modal-content');
    
    if (!modal || !titleEl || !contentEl) return;
    
    // Show the modal
    modal.style.display = 'block';
    
    titleEl.textContent = title;
    
    if (results.length === 0) {
        contentEl.innerHTML = '<p style="text-align: center; color: #6b7280; padding: 2rem;">No results found.</p>';
    } else {
        // First check if results are business entities (has entity data or is external business data)
        // Note: We check entities FIRST because they can also have file-like properties
        const firstResult = results.length > 0 ? results[0] : null;
        const isBusinessEntityResult = firstResult && (
            (firstResult.original_data && (
                firstResult.original_data.vendor_name || 
                firstResult.original_data.customer_name || 
                firstResult.original_data.donor_name ||
                firstResult.original_data.item_name ||
                firstResult.original_data.amount ||
                firstResult.original_data.balance ||
                firstResult.original_data.expense_id ||
                firstResult.original_data.order_id
            )) ||
            firstResult.data_type ||
            firstResult.mimeType === 'application/external' ||
            firstResult.mime_type === 'application/external'
        );
        
        // Check if results are regular files (not business entities)
        const isFileResults = !isBusinessEntityResult && results.length > 0 && (
            results[0].file_name || results[0].file_path || results[0].mime_type || 
            results[0].fileName || results[0].filePath || results[0].mimeType
        );
        
        // Extract search query from title for highlighting
        const searchQueryMatch = title.match(/\"([^\"]+)\"/);
        const searchQuery = searchQueryMatch ? searchQueryMatch[1].toLowerCase() : '';
        
        // Helper function to highlight search terms in text
        function highlightText(text, query) {
            if (!query || !text) return escapeHtml(String(text));
            const escapedText = escapeHtml(String(text));
            const regex = new RegExp('(' + escapeHtml(query).replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi');
            return escapedText.replace(regex, '<mark style="background: #fef08a; padding: 0.1em 0.2em; border-radius: 3px; font-weight: 600;">$1</mark>');
        }
        
        // Helper function to extract snippet with search term
        function getSnippet(text, query, maxLength = 200) {
            if (!text) return '';
            const textStr = String(text).toLowerCase();
            const queryLower = query.toLowerCase();
            const queryIndex = textStr.indexOf(queryLower);
            
            if (queryIndex === -1) {
                // Query not found, return beginning
                return text.substring(0, maxLength);
            }
            
            // Start a bit before the match, end a bit after
            const start = Math.max(0, queryIndex - 50);
            const end = Math.min(text.length, queryIndex + query.length + 50);
            let snippet = text.substring(start, end);
            
            if (start > 0) snippet = '...' + snippet;
            if (end < text.length) snippet = snippet + '...';
            
            return snippet;
        }
        
        // Group results by category/type
        const groupedResults = {};
        results.forEach((result, index) => {
            // Use data_type as source of truth (replaced entity_key)
            // Fail fast: data_type is required
            const entityKey = result.data_type || result.dataType || result.entity_key || result.entityKey || result.entity_type;
            if (!entityKey) {
                console.error('‚ùå Missing entity_key in result:', result);
                return; // Skip this result
            }
            const category = entityKey.charAt(0).toUpperCase() + entityKey.slice(1);
            
            if (!groupedResults[category]) {
                groupedResults[category] = [];
            }
            groupedResults[category].push({...result, originalIndex: index});
        });
        
        // Sort categories by result count (most results first)
        const sortedCategories = Object.keys(groupedResults).sort((a, b) => groupedResults[b].length - groupedResults[a].length);
        
        let html = '';
        
        // Root cause fix: When all results belong to a single category (common for entity type searches),
        // skip category grouping/header to avoid duplicating what's already in the modal title.
        // Category grouping is useful when there are multiple categories, but redundant for single-category results.
        const hasSingleCategory = sortedCategories.length === 1;
        const shouldSkipCategoryGrouping = hasSingleCategory;
        
        // Generate grouped HTML
        sortedCategories.forEach((category, categoryIndex) => {
            const categoryResults = groupedResults[category];
            const resultCount = categoryResults.length;
            
            if (shouldSkipCategoryGrouping) {
                // Single category: skip grouping header, just show results directly
                html += '<div style="margin-top: 0;">';
            } else {
                // Multiple categories: show category header
                html += '<div style="margin-top: ' + (categoryIndex > 0 ? '1.25rem' : '0') + ';">';
                html += '<div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; padding-bottom: 0.375rem; border-bottom: 1px solid #e5e7eb;">';
                html += '<h3 style="margin: 0; font-size: 1rem; font-weight: 700; color: #111827;">' + escapeHtml(category) + '</h3>';
                html += '<span style="background: #e5e7eb; color: #6b7280; padding: 0.125rem 0.5rem; border-radius: 8px; font-size: 0.75rem; font-weight: 600;">' + resultCount + ' result' + (resultCount !== 1 ? 's' : '') + '</span>';
                html += '</div>';
            }
            
            html += '<div style="display: grid; gap: 0.75rem;">';
            
            categoryResults.forEach((result) => {
                // Debug: Log EVERY result to see what we're processing
                console.log('üîç Processing result:', {
                    aiCategory: result.aiCategory,
                    ai_category: result.ai_category,
                    hasOriginalData: !!result.original_data,
                    dataType: result.data_type,
                    id: result.id
                });
                
                // Extract entity data
                // Format: API returns { original_data: {...}, data_type: ..., id: ..., etc. }
                // Fail fast: Must have original_data
                if (!result.original_data) {
                    console.error(`‚ùå Search result missing required structure (original_data):`, result);
                    return;
                }
                
                const originalData = result.original_data;
                
                // Debug: Log data structure for entities with amount fields (generic)
                const hasAmountField = originalData.amount || result.amount;
                if (hasAmountField) {
                    console.log(`üîç Entity data structure (${result.data_type || 'unknown'}):`, {
                        originalDataAmount: originalData.amount,
                        resultAmount: result.amount,
                        dataType: result.data_type,
                        originalDataKeys: Object.keys(originalData || {}).slice(0, 20)
                    });
                }
                
                // Check if this is an entity result (has entity data in original_data)
                // Include QuickBooks capitalized fields (Name, Type, Id, Description, etc.)
                const hasEntityData = originalData._entity_type ||
                                    originalData.vendor_name || originalData.customer_name || originalData.donor_name ||
                                    originalData.item_name || originalData.amount || originalData.balance ||
                                    originalData.expense_id || originalData.order_id || originalData.description ||
                                    originalData.DisplayName || originalData.Id || originalData.type ||
                                    originalData.Name || originalData.Type || originalData.Description || // QuickBooks capitalized fields
                                    result.name || result.customer_name || result.donor_name;
                
                // Also check if it's an external business data file (not a regular file)
                // Check for data_type at top level
                const isBusinessEntity = originalData._entity_type ||
                                       result.mimeType === 'application/external' || 
                                       result.mime_type === 'application/external' ||
                                       result.data_type;
                
                // Debug: Log hasEntityData check with full originalData inspection
                const originalDataKeys = Object.keys(originalData || {});
                const originalDataFull = originalData || {};
                console.log('üîç Entity check:', {
                    hasEntityData: hasEntityData,
                    isBusinessEntity: isBusinessEntity,
                    originalDataKeys: originalDataKeys,
                    originalDataKeysCount: originalDataKeys.length,
                    originalDataKeysList: originalDataKeys.join(', '),
                    originalDataFull: originalDataFull,  // Show ALL fields and values
                    dataType: result.data_type,
                    id: result.id,
                    aiCategory: result.aiCategory
                });
                
                // Check if this is a file result (has file fields) - files should NOT use entity schemas
                const isFileResult = result.file_name || result.file_path || result.mime_type || 
                                   originalData.file_name || originalData.file_path || originalData.mime_type;
                
                // Display entity data if this is a business entity AND NOT a file (regardless of isFileResults flag)
                if ((hasEntityData || isBusinessEntity) && !isFileResult) {
                    console.log('‚úÖ Entering entity rendering block');
                    // Get entity type - use data_type from result (replaced entity_key)
                    // Fail fast: data_type is required
                    const entityType = result.data_type || result.dataType || result.entity_key || result.entityKey || result.entity_type || null;
                    if (!entityType) {
                        console.error('‚ùå Missing entity_key in result:', result);
                        return; // Skip this result
                    }
                    
                    // Debug: log entity type detection for donations
                    if (entityType === 'donation' || entityType === 'Donation') {
                        console.log('üîç Donation entity detected:', {
                            entityType: entityType,
                            originalDataAmount: originalData.amount
                        });
                    }
                    
                    // Get schema for this entity type (defines which fields to display)
                    let schema;
                    try {
                        schema = getEntitySchemaForType(entityType);
                    } catch (error) {
                        console.error('‚ùå Cannot render entity:', entityType, '-', error.message);
                        // Skip this entity - schema not available from Crema
                        return;
                    }
                    
                    // Debug: log schema and data before extraction (for all entities to see what's happening)
                    console.log('üîç Entity processing:', {
                        entityType: entityType,
                        normalizedType: String(entityType).toLowerCase().replace(/[^a-z0-9_]/g, ''),
                        schemaExists: !!schema,
                        hasHeaderFields: !!schema.headerFields,
                        headerFieldsAmount: schema.headerFields?.amount,
                        originalDataAmount: originalData.amount,
                        resultAiCategory: result.ai_category || result.aiCategory,
                        dataType: result.data_type
                    });
                    
                    // Display all fields directly from originalData without extraction
                    // Simple approach: show all fields as-is
                    
                    // Get all fields from originalData - no categorization, no transformation, no formatting
                    const allFields = [];
                    Object.keys(originalData || {}).forEach(key => {
                        const value = originalData[key];
                        const label = formatFieldLabel(key);  // Returns key as-is
                        // Show value exactly as-is - no formatting
                        let rawValue = value;
                        if (value === null) {
                            rawValue = 'null';
                        } else if (value === undefined) {
                            rawValue = 'undefined';
                        } else if (typeof value === 'object') {
                            rawValue = JSON.stringify(value);
                        } else {
                            rawValue = String(value);
                        }
                        
                        allFields.push({
                            key: key,
                            label: label,
                            value: rawValue
                        });
                    });
                    
                    // Extract entity name from available fields
                    const entityName = originalData.Name || 
                                      originalData.name || 
                                      originalData.display_name || 
                                      originalData.DisplayName ||
                                      originalData.id || 
                                      originalData.Id ||
                                      result.id ||
                                      entityType ||
                                      'Entity';
                    
                    // Create simple header with entity ID
                    html += '<div style="background: white; border: 1px solid rgba(165, 29, 53, 0.2); border-radius: 8px; overflow: hidden; margin-bottom: 0.75rem; box-shadow: 0 1px 3px rgba(165, 29, 53, 0.1);">';
                    html += '<div style="background: linear-gradient(135deg, #A51D35 0%, #8B1A2E 100%); padding: 0.75rem 1.25rem; color: white;">';
                    html += '<div style="font-weight: 700; font-size: 1.25rem; line-height: 1.4;">' + escapeHtml(String(entityName)) + '</div>';
                    html += '</div></div>';
                    
                    // Content: Show all fields together - no categorization
                    html += '<div style="padding: 1rem 1.25rem;">';
                    if (allFields.length > 0) {
                        html += '<div style="display: flex; flex-direction: row; flex-wrap: wrap; gap: 0.75rem; align-items: flex-start;">';
                        allFields.forEach(field => {
                            html += '<div style="padding: 0.5rem; background: #f9fafb; border-radius: 4px; flex: 0 0 auto;">';
                            html += '<div style="font-size: 0.75rem; font-weight: 600; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">' + escapeHtml(field.label) + '</div>';
                            
                            const valueStr = String(field.value);
                            
                            // Special handling for file_name and file_path fields
                            const isFileField = (field.key === 'file_name' || field.key === 'file_path' || field.key === 'fileName' || field.key === 'filePath');
                            const isFileEntity = (originalData.file_name || originalData.fileName) && 
                                                (originalData.file_path || originalData.filePath) && 
                                                (originalData.mime_type || originalData.mimeType);
                            const fileId = isFileEntity ? (originalData.id || result.id || '') : '';
                            const filePath = originalData.file_path || originalData.filePath || (field.key === 'file_path' ? valueStr : '');
                            const mimeType = originalData.mime_type || originalData.mimeType || 'application/octet-stream';
                            
                            if (isFileField && fileId && valueStr) {
                                html += '<div style="font-size: 0.875rem; color: #111827; word-break: break-word;">';
                                html += '<a href="#" onclick="event.preventDefault(); openFile(\'' + escapeHtml(fileId) + '\', \'' + escapeHtml(filePath || valueStr) + '\', \'' + escapeHtml(mimeType) + '\'); return false;" ';
                                html += 'style="color: #A51D35; text-decoration: underline; cursor: pointer; font-weight: 500;">' + escapeHtml(valueStr) + '</a>';
                                html += '</div>';
                            } else if (valueStr.includes('\n')) {
                                html += '<div style="font-size: 0.875rem; color: #111827; word-break: break-word; white-space: pre-wrap; font-family: \'Monaco\', \'Menlo\', \'Courier New\', monospace; background: #ffffff; padding: 0.5rem; border-radius: 3px; border: 1px solid #e5e7eb; max-height: 200px; overflow-y: auto;">' + escapeHtml(valueStr) + '</div>';
                            } else {
                                html += '<div style="font-size: 0.875rem; color: #111827; word-break: break-word;">' + escapeHtml(valueStr) + '</div>';
                            }
                            html += '</div>';
                        });
                        html += '</div>';
                    }
                    
                    html += '</div></div>';
                } else if (isFileResults || isFileResult) {
                    // File display mode - handle both file results from file searches and files detected in entity searches
                    // Note: For files returned from API, result IS the file data (not wrapped in metadata)
                    const fileOriginalData = originalData || {};
                    
                    // Extract a better display name from file data
                    // For files returned from API, result IS the file data with file_name, file_path, etc.
                    let displayName = result.file_name || result.fileName ||
                                    fileOriginalData.name || fileOriginalData.customer_name || fileOriginalData.title || 
                                    result.id || 'Unknown File';
                    
                    // Clean up the display name - remove redundant prefixes and file extensions
                    if (typeof displayName === 'string') {
                        // Remove file extensions
                        displayName = displayName.replace(/\.json$/, '').replace(/\.(txt|pdf|doc|docx|xls|xlsx)$/i, '');
                        // Remove redundant prefixes like "customers_customers_customers_"
                        displayName = displayName.replace(/^(customers|payments|employees|orders|timesheets)_+(customers|payments|employees|orders|timesheets)_+/, '');
                        // Replace underscores with spaces
                        displayName = displayName.replace(/_/g, ' ');
                        // Capitalize words
                        displayName = displayName.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');
                    }
                    
                    const filePath = result.file_path || result.filePath || '';
                    const fileSize = result.file_size || result.fileSize || 0;
                    const mimeType = result.mime_type || result.mimeType || 'unknown';
                    // CRITICAL: Extract file ID from multiple possible locations
                    // For file results, id should be at top level
                    // For entities with file fields, id might be in originalData
                    const fileId = result.id || result.file_id || fileOriginalData.id || fileOriginalData.file_id || '';
                    const modifiedAt = result.modified_at || result.modifiedAt || result.updated_at || result.updatedAt || result.created_at || result.createdAt || null;
                    const relevanceScore = result.relevance_score || result.relevanceScore || null;
                    
                    // Extract content for snippet from original_data (no metadata column anymore)
                    const contentStr = typeof originalData === 'object' ? JSON.stringify(originalData) : String(originalData || '');
                    
                    // Get snippet highlighting search term
                    let snippetHtml = '';
                    if (searchQuery && contentStr) {
                        const snippet = getSnippet(contentStr, searchQuery, 200);
                        if (snippet) {
                            snippetHtml = '<div style="font-size: 0.8rem; color: #4b5563; margin-top: 0.5rem; padding: 0.5rem; background: #ffffff; border-left: 2px solid #3b82f6; border-radius: 3px; line-height: 1.4;">' +
                                         '<div style="font-weight: 600; color: #6b7280; margin-bottom: 0.125rem; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;">MATCH</div>' +
                                         highlightText(snippet, searchQuery) +
                                         '</div>';
                        }
                    }
                
                // Format file size
                let sizeStr = '';
                if (fileSize > 0) {
                    if (fileSize < 1024) {
                        sizeStr = fileSize + ' B';
                    } else if (fileSize < 1024 * 1024) {
                        sizeStr = (fileSize / 1024).toFixed(1) + ' KB';
                    } else if (fileSize < 1024 * 1024 * 1024) {
                        sizeStr = (fileSize / (1024 * 1024)).toFixed(1) + ' MB';
                    } else {
                        sizeStr = (fileSize / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
                    }
                }
                
                // Format date
                let dateStr = '';
                if (modifiedAt) {
                    const date = typeof modifiedAt === 'string' ? new Date(modifiedAt) : new Date(modifiedAt * 1000);
                    dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                }
                
                // Get file icon based on MIME type
                let fileIcon = 'üìÑ';
                if (mimeType.startsWith('image/')) fileIcon = 'üñºÔ∏è';
                else if (mimeType.startsWith('video/')) fileIcon = 'üé¨';
                else if (mimeType.startsWith('audio/')) fileIcon = 'üéµ';
                else if (mimeType.includes('pdf')) fileIcon = 'üìï';
                else if (mimeType.includes('word') || mimeType.includes('document')) fileIcon = 'üìù';
                else if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) fileIcon = 'üìä';
                else if (mimeType.includes('zip') || mimeType.includes('archive')) fileIcon = 'üì¶';
                
                // Build category/entity type badges
                let badgesHtml = '';
                // Use data_type instead of entity_key (replaced entity_key)
                const entityKey = result.data_type || result.dataType || result.entity_key || result.entityKey || result.entity_type || '';
                const aiTags = result.ai_tags || result.aiTags || [];
                
                if (entityKey) {
                    badgesHtml += '<span style="background: #dbeafe; color: #1e40af; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600; margin-right: 0.375rem;">' + escapeHtml(entityKey) + '</span>';
                }
                if (aiTags && aiTags.length > 0) {
                    aiTags.slice(0, 2).forEach(tag => {
                        badgesHtml += '<span style="background: #f3f4f6; color: #374151; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.7rem; margin-right: 0.375rem;">' + escapeHtml(tag) + '</span>';
                    });
                }
                if (mimeType === 'application/external' && !entityKey) {
                    badgesHtml += '<span style="background: #fef3c7; color: #92400e; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.7rem;">Business Data</span>';
                }
                
                // Relevance score badge
                let relevanceBadge = '';
                if (relevanceScore !== null && relevanceScore > 0) {
                    const scorePercent = (relevanceScore * 100).toFixed(0);
                    relevanceBadge = '<span style="background: #dcfce7; color: #166534; padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.7rem; font-weight: 600; margin-left: 0.375rem;" title="Relevance Score: ' + relevanceScore.toFixed(4) + '">' + scorePercent + '%</span>';
                }
                
                // Build file metadata HTML safely
                let sizeHtml = sizeStr ? '<span style="font-size: 0.8rem;"><strong>Size:</strong> ' + sizeStr + '</span>' : '';
                let dateHtml = dateStr ? '<span style="font-size: 0.8rem;"><strong>Modified:</strong> ' + dateStr + '</span>' : '';
                let pathHtml = filePath ? '<div style="font-size: 0.75rem; color: #9ca3af; margin-top: 0.375rem; word-break: break-all; font-family: monospace;">' + escapeHtml(filePath) + '</div>' : '';
                
                // Extract structured data from original_data for business entities
                let structuredDataHtml = '';
                if (mimeType === 'application/external' && originalData) {
                    const extractedFields = [];
                    if (originalData.name) extractedFields.push(['Name', originalData.name]);
                    if (originalData.customer_name) extractedFields.push(['Customer', originalData.customer_name]);
                    if (originalData.email) extractedFields.push(['Email', originalData.email]);
                    if (originalData.phone) extractedFields.push(['Phone', originalData.phone]);
                    if (originalData.address) extractedFields.push(['Address', originalData.address]);
                    if (originalData.balance !== undefined) extractedFields.push(['Balance', '$' + parseFloat(originalData.balance || 0).toFixed(2)]);
                    
                    if (extractedFields.length > 0) {
                        structuredDataHtml = '<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #e5e7eb;">';
                        extractedFields.forEach(([label, value]) => {
                            structuredDataHtml += '<div style="font-size: 0.8rem; margin-bottom: 0.125rem; display: inline-block; margin-right: 1rem;"><strong style="color: #6b7280;">' + escapeHtml(label) + ':</strong> <span style="color: #111827;">' + highlightText(String(value), searchQuery) + '</span></div>';
                        });
                        structuredDataHtml += '</div>';
                    }
                }
                
                // Use data attributes for file info instead of inline onclick to avoid escaping issues
                html += ('<div style="border: 1px solid rgba(165, 29, 53, 0.2); border-radius: 6px; padding: 0.75rem; background: rgba(165, 29, 53, 0.03); cursor: pointer; transition: all 0.2s; box-shadow: 0 1px 2px rgba(165, 29, 53, 0.05);" ' +
                        'data-file-id="' + escapeHtml(fileId) + '" ' +
                        'data-file-path="' + escapeHtml(filePath).replace(/"/g, "&quot;") + '" ' +
                        'data-mime-type="' + escapeHtml(mimeType).replace(/"/g, "&quot;") + '" ' +
                        'onclick="openFile(this.getAttribute(\'data-file-id\'), this.getAttribute(\'data-file-path\'), this.getAttribute(\'data-mime-type\'))" ' +
                        'onmouseover="this.style.background=\'#ffffff\'; this.style.borderColor=\'#A51D35\'; this.style.boxShadow=\'0 2px 4px rgba(165, 29, 53, 0.2)\';" ' +
                        'onmouseout="this.style.background=\'rgba(165, 29, 53, 0.03)\'; this.style.borderColor=\'rgba(165, 29, 53, 0.2)\'; this.style.boxShadow=\'0 1px 2px rgba(165, 29, 53, 0.05)\';" ' +
                        '>' +
                        '<div style="display: flex; align-items: flex-start; gap: 0.75rem;">' +
                        '<div style="font-size: 1.5rem; flex-shrink: 0; line-height: 1;">' + fileIcon + '</div>' +
                        '<div style="flex: 1; min-width: 0;">' +
                        '<div style="display: flex; align-items: center; margin-bottom: 0.375rem; flex-wrap: wrap; gap: 0.375rem;">' +
                        '<div style="font-weight: 600; color: #111827; font-size: 0.95rem; word-break: break-word; flex: 1; line-height: 1.3;">' + highlightText(displayName, searchQuery) + '</div>' +
                        (badgesHtml ? '<div style="display: flex; flex-wrap: wrap; gap: 0.25rem; margin-left: 0.375rem;">' + badgesHtml + '</div>' : '') +
                        relevanceBadge +
                        '</div>' +
                        '<div style="display: flex; gap: 0.75rem; flex-wrap: wrap; color: #6b7280; margin-bottom: 0.375rem;">' +
                        sizeHtml +
                        dateHtml +
                        '<span style="font-size: 0.8rem;"><strong>Type:</strong> ' + escapeHtml(mimeType) + '</span>' +
                        '</div>' +
                        pathHtml +
                        structuredDataHtml +
                        snippetHtml +
                        '</div>' +
                        '<div style="color: #3b82f6; font-weight: 600; font-size: 0.8rem; margin-top: 0.5rem; text-align: right; flex-shrink: 0;">Click to open ‚Üí</div>' +
                        '</div>' +
                        '</div>');
                }
            });
            
            html += '</div>';  // Close category results grid
            html += '</div>';  // Close category section
        });
        
        
        html += '<div style="text-align: center; color: #6b7280; margin-top: 1.5rem; padding-top: 0.75rem; border-top: 1px solid #e5e7eb; font-size: 0.85rem;">';
        html += '<strong>Total:</strong> ' + results.length + ' result' + (results.length !== 1 ? 's' : '') + ' across ' + sortedCategories.length + ' categor' + (sortedCategories.length !== 1 ? 'ies' : 'y');
        html += '</div>';
        contentEl.innerHTML = html;
    }
    
    modal.style.display = 'block';
}

// Function to open file in OS default viewer/player
function openFile(fileId, filePath, mimeType) {
    // Static mode: File content not available
    return;
}

function closeResultsModal() {
    const modal = document.getElementById('results-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Handle entity card clicks (entire card or button)
document.addEventListener('click', async (e) => {
    // Check if clicked on entity card
    const entityCard = e.target.closest('.entity-type-card');
    
    if (entityCard) {
        const entityKey = entityCard.dataset.entityType || entityCard.getAttribute('data-entity-type');
        const entityName = entityCard.dataset.entityName || entityCard.getAttribute('data-entity-name');
        
        if (!entityKey) return;
        
        // Find entity type from CREMA_DATA
        const entityType = CREMA_DATA.data_types.find(et => (et.data_type || et.key) === entityKey);
        if (!entityType) {
            console.error('‚ö†Ô∏è Entity type not found:', entityKey);
            return;
        }
        
        const results = await searchEntity(entityType);
        showResultsModal(entityName + ' (' + results.length + ' found)', results);
    }
    
    // Category card handlers removed - file types (image, video, document, etc.) are now entity types
    // They appear in the entity tiles section and use searchEntity() instead
    
    // Search functionality moved to business-data.html
});

// Global search function - static mode (not available)
async function searchGlobal(query) {
    return [];
}

// Handle Enter key in search input
document.addEventListener('DOMContentLoaded', () => {
    // Search functionality moved to business-data.html
    
    // Time range selector
    const timeRangeSelect = document.getElementById('time-range-select');
    if (timeRangeSelect) {
        timeRangeSelect.addEventListener('change', async () => {
            const timeRange = timeRangeSelect.value;
            console.log('üîÑ Time range changed to:', timeRange);
            
            // Clear any pending board analyses timeout to avoid loading stale data
            if (window.boardAnalysesTimeout) {
                clearTimeout(window.boardAnalysesTimeout);
                window.boardAnalysesTimeout = null;
                console.log('üßπ Cleared pending board analyses timeout');
            }
            
            try {
                // Insights disabled for performance
                await Promise.all([
                    fetchMetricsWithTimeRange(timeRange)
                    // fetchInsights(timeRange)  // Disabled for performance
                ]);
                console.log('‚úÖ Metrics updated for time range:', timeRange);
            } catch (error) {
                console.error('‚ùå Error updating metrics for time range:', timeRange, error);
            }
        });
    } else {
        console.warn('‚ö†Ô∏è Time range selector not found');
    }
});

// Fetch metrics for a time range (static mode - cache only)
async function fetchMetricsWithTimeRange(timeRange = 'this_year') {
    console.log(`üìä Fetching metrics for time range: ${timeRange} (mode: cache)`);
    showLoading('metrics');
    
    try {
        // Map UI time range to cache file time range
        let kandaqTimeRange;
        if (timeRange && timeRange.startsWith('year_')) {
            kandaqTimeRange = timeRange;
        } else {
            const timeRangeMap = {
                'today': 'today',
                'this_week': 'this_week',
                'last_week': 'last_week',
                'this_month': 'this_month',
                'last_month': 'last_month',
                'this_quarter': 'this_quarter',
                'last_quarter': 'last_quarter',
                'this_year': 'this_year',
                'last_year': 'last_year',
                'all_time': 'all_time',
                'week': 'this_week',
                'month': 'this_month',
                'year': 'this_year',
                'current_year': 'this_year'
            };
            kandaqTimeRange = timeRangeMap[timeRange];
            if (!kandaqTimeRange) {
                throw new Error(`Invalid time range: "${timeRange}"`);
            }
        }
        
        // Use CremaClient to get metrics from cache
        const metrics = await crema.getMetrics(kandaqTimeRange);
        
        if (!metrics) {
            throw new Error('No metrics data returned');
        }
        
        // Get source targets and full cache data if available
        let sourceTargets = {};
        let boardMetrics = metrics;
        
        try {
            // Load full cache file to get source_targets and board analyses
            const cacheData = await crema.loadCacheFile(kandaqTimeRange);
            sourceTargets = cacheData?.source_targets || {};
            // Use full cache metrics for board analyses (may have more data)
            if (cacheData?.metrics) {
                boardMetrics = cacheData.metrics;
            }
        } catch (e) {
            console.warn('‚ö†Ô∏è Could not load full cache file:', e);
            // Continue with metrics-only data
        }
        
        // Update metrics display
        if (typeof updateMetrics === 'function') {
            updateMetrics(metrics, timeRange, sourceTargets);
        }
        
        // Process board analyses for nonprofits
        if (BUSINESS_TYPE === 'non_profit_organization') {
            
            // Process board analyses
            if (boardMetrics?.revenue_by_source && typeof updateRevenueBySource === 'function') {
                updateRevenueBySource(boardMetrics.revenue_by_source);
            }
            if (boardMetrics?.expenses_by_type && typeof updateExpensesByType === 'function') {
                updateExpensesByType(boardMetrics.expenses_by_type);
            }
            if (boardMetrics?.programs && typeof updatePrograms === 'function') {
                updatePrograms(boardMetrics.programs);
            }
            if (boardMetrics?.top_donors && typeof updateTopDonors === 'function') {
                updateTopDonors(boardMetrics.top_donors);
            }
            if (boardMetrics?.funds && typeof updateFunds === 'function') {
                updateFunds(boardMetrics.funds);
            }
        }
        
        // Update time range label
        const timeRangeLabels = {
            'today': 'Today',
            'this_week': 'This Week',
            'last_week': 'Last Week',
            'this_month': 'This Month',
            'last_month': 'Last Month',
            'this_quarter': 'This Quarter',
            'last_quarter': 'Last Quarter',
            'this_year': 'This Year',
            'last_year': 'Last Year',
            'all_time': 'All Time'
        };
        const timeRangeLabel = timeRangeLabels[timeRange] || (timeRange.startsWith('year_') ? timeRange.split('_')[1] : timeRange);
        
        const metricsSection = document.querySelector('.metrics-section h2');
        if (metricsSection) {
            const existingLabel = metricsSection.querySelector('.time-range-label');
            if (existingLabel) {
                existingLabel.textContent = ' (' + timeRangeLabel + ')';
            } else {
                const label = document.createElement('span');
                label.className = 'time-range-label';
                label.style.fontSize = '0.75em';
                label.style.color = '#6b7280';
                label.style.fontWeight = 'normal';
                label.textContent = ' (' + timeRangeLabel + ')';
                metricsSection.appendChild(label);
            }
        }
        
        hideLoading('metrics');
        console.log('‚úÖ Metrics updated for time range:', timeRange);
        
    } catch (error) {
        hideLoading('metrics');
        console.error('‚ùå Error fetching metrics:', error);
        showError('Failed to load metrics: ' + error.message, 'metrics');
    }
}

// Format bytes helper
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// Format metric value based on metric type
function formatMetricValue(metricId, value) {
    if (value === null || value === undefined || value === '') {
        return '‚Äî';
    }
    
    // Handle percentage metrics
    if (metricId.includes('margin') || metricId.includes('percentage') || metricId.includes('ratio')) {
        const numValue = typeof value === 'string' ? parseFloat(value.replace(/[^0-9.-]/g, '')) : Number(value);
        if (isNaN(numValue)) return '‚Äî';
        return numValue.toFixed(1) + '%';
    }
    
    // Handle currency metrics
    if (metricId.includes('revenue') || metricId.includes('expenses') || metricId.includes('income') || 
        metricId.includes('profit') || metricId.includes('donation') || metricId.includes('amount') ||
        metricId.includes('total') || metricId.includes('net')) {
        const numValue = typeof value === 'string' ? parseFloat(value.replace(/[^0-9.-]/g, '')) : Number(value);
        if (isNaN(numValue)) return '‚Äî';
        return '$' + numValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    
    // Handle count metrics
    if (metricId.includes('count') || metricId.includes('number') || metricId.includes('total_')) {
        const numValue = typeof value === 'string' ? parseFloat(value.replace(/[^0-9.-]/g, '')) : Number(value);
        if (isNaN(numValue)) return '‚Äî';
        return numValue.toLocaleString('en-US');
    }
    
    // Default: return as-is or format as number if numeric
    const numValue = typeof value === 'string' ? parseFloat(value.replace(/[^0-9.-]/g, '')) : Number(value);
    if (!isNaN(numValue)) {
        return numValue.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 2 });
    }
    
    return String(value);
}

function updateMetrics(data, timeRange = 'this_year', sourceTargets = {}) {
    // Update metric cards with real data
    const timeRangeLabels = {
        'today': 'Today',
        'this_week': 'This Week',
        'last_week': 'Last Week',
        'this_month': 'This Month',
        'last_month': 'Last Month',
        'this_quarter': 'This Quarter',
        'last_quarter': 'Last Quarter',
        'this_year': 'This Year',
        'last_year': 'Last Year',
        'all_time': 'All Time',
        'week': 'This Week',
        'month': 'This Month',
        'year': 'This Year',
        'current_year': 'This Year'
    };
    let timeRangeLabel;
    if (timeRange && timeRange.startsWith('year_')) {
        const year = timeRange.split('_')[1];
        timeRangeLabel = year;
    } else {
        timeRangeLabel = timeRangeLabels[timeRange];
        if (!timeRangeLabel) {
            console.warn(`Invalid time range for label: "${timeRange}"`);
            timeRangeLabel = timeRange;
        }
    }
    
    // Use sourceTargets parameter if provided, otherwise try to get from data
    if (!sourceTargets || Object.keys(sourceTargets).length === 0) {
        sourceTargets = data._source_targets || {};
    }
    
    // Extract targets for the current time range
    let targetsForTimeRange = {};
    if (sourceTargets && typeof sourceTargets === 'object') {
        if (timeRange && sourceTargets[timeRange]) {
            targetsForTimeRange = sourceTargets[timeRange];
        } else {
            targetsForTimeRange = sourceTargets;
        }
    }
    
    console.log('üîÑ updateMetrics called with', Object.keys(data).length, 'metrics');
    
    // If no data, show empty state
    if (!data || Object.keys(data).length === 0) {
        console.warn('‚ö†Ô∏è No metrics data to display');
        document.querySelectorAll('.metric-card .metric-value').forEach(el => {
            el.textContent = '‚Äî';
        });
        return;
    }
    
    // Board analysis components that are handled separately (not metric cards)
    const boardAnalysisKeys = ['top_donors', 'programs', 'revenue_by_source', 'expenses_by_type'];
    
    Object.keys(data).forEach(metricId => {
        // Skip internal fields
        if (metricId.startsWith('_')) return;
        
        // Skip board analysis components (handled separately)
        if (boardAnalysisKeys.includes(metricId)) return;
        
        const element = document.querySelector('[data-metric-id="' + metricId + '"]');
        if (!element) {
            return;
        }
        
        const valueElement = element.querySelector('.metric-value');
        const targetElement = element.querySelector('.metric-target');
        
        if (valueElement) {
            const value = data[metricId];
            
            // Extract value if it's an object (remove trend info)
            let displayValue = value;
            if (typeof value === 'object' && value !== null) {
                if (value.value !== undefined) {
                    displayValue = value.value;
                } else if (typeof value === 'string') {
                    displayValue = value;
                }
            }
            
            // Hide expenses metric if value is zero
            if (metricId === 'expenses') {
                const numValue = typeof displayValue === 'string' 
                    ? parseFloat(displayValue.replace(/[^0-9.-]/g, '')) 
                    : Number(displayValue);
                if (numValue === 0 || isNaN(numValue)) {
                    element.style.display = 'none';
                    return;
                } else {
                    element.style.display = '';
                }
            }
            
            valueElement.innerHTML = formatMetricValue(metricId, displayValue);
            
            // Check for source target and update UI
            let targetInfo = targetsForTimeRange[metricId];
            if (!targetInfo) {
                const baseMetricId = metricId.replace(/_(quickbooks|aplos)$/, '');
                targetInfo = targetsForTimeRange[baseMetricId];
            }
            
            if (targetInfo && targetElement && targetInfo.target != null && targetInfo.target !== undefined) {
                const targetValue = targetInfo.target;
                const isMatch = targetInfo.match;
                const percentDiff = targetInfo.percent_difference || 0;
                
                targetElement.style.display = 'block';
                const textColor = isMatch ? '#065f46' : '#ffffff';
                const labelColor = isMatch ? '#047857' : '#ffffff';
                targetElement.style.cssText = `display: block; margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid ${isMatch ? '#e5e7eb' : 'rgba(255,255,255,0.3)'}; font-size: 0.875rem; line-height: 1.5; color: ${textColor}; font-weight: ${isMatch ? '500' : '600'};`;
                
                let varianceInfo = '';
                if (percentDiff !== null && percentDiff !== undefined && !isNaN(percentDiff)) {
                    let varianceText;
                    if (percentDiff < 0.1) {
                        varianceText = `${percentDiff.toFixed(2)}% variance`;
                    } else if (percentDiff < 1) {
                        varianceText = `${percentDiff.toFixed(1)}% variance`;
                    } else if (percentDiff < 10) {
                        varianceText = `${percentDiff.toFixed(1)}% variance`;
                    } else {
                        varianceText = `${percentDiff.toFixed(0)}% variance`;
                    }
                    varianceInfo = `<span style="color: ${labelColor}; opacity: 0.8; font-size: 0.8rem; margin-left: 0.5rem;">(${varianceText})</span>`;
                }
                
                targetElement.innerHTML = `
                    <span class="metric-match-indicator" style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 0.5rem; vertical-align: middle; background-color: ${isMatch ? '#10b981' : '#ffffff'};"></span>
                    <span style="color: ${labelColor};">Target: </span>
                    <span class="metric-target-value" style="font-weight: 700; color: ${textColor};">${formatMetricValue(metricId, targetValue)}</span>
                    ${varianceInfo}
                `;
                
                element.classList.remove('metric-match', 'metric-mismatch');
                if (isMatch) {
                    element.classList.add('metric-match');
                    element.style.borderLeftColor = '';
                    element.style.borderLeftWidth = '';
                    element.style.backgroundColor = '';
                } else {
                    element.classList.add('metric-mismatch');
                    element.style.borderLeftColor = '#f59e0b';
                    element.style.borderLeftWidth = '6px';
                    element.style.backgroundColor = '#fffbeb';
                }
            } else if (targetElement) {
                targetElement.style.display = 'none';
                element.classList.remove('metric-match', 'metric-mismatch');
                element.style.borderLeftColor = '';
                element.style.borderLeftWidth = '';
                element.style.backgroundColor = '';
            }
        }
        
        const timeBadge = element.querySelector('.metric-time-badge');
        if (timeBadge) {
            timeBadge.remove();
        }
    });
}

function updateRevenueBySource(data) {
    if (!data || !data.sources) return;
    const sectionContainer = document.getElementById('revenue-by-source-section-container');
    if (sectionContainer) sectionContainer.style.display = 'block';
    const sourcesList = document.getElementById('revenue-sources-list');
    if (!sourcesList) return;
    sourcesList.innerHTML = '';
    const sources = Object.entries(data.sources).sort((a, b) => b[1].total - a[1].total);
    sources.forEach(([sourceName, sourceData]) => {
        const sourceCard = document.createElement('div');
        sourceCard.className = 'board-analysis-card';
        let breakdownHTML = '';
        if (sourceData.breakdown) {
            breakdownHTML = '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;"><div style="font-size: 0.85rem; color: #6b7280; margin-bottom: 0.75rem; font-weight: 600;">Breakdown:</div>';
            const breakdownEntries = Object.entries(sourceData.breakdown).sort((a, b) => b[1].total - a[1].total);
            breakdownEntries.forEach(([breakdownName, breakdownData]) => {
                breakdownHTML += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; padding: 0.75rem; background: #f9fafb; border-radius: 6px;"><div style="display: flex; align-items: center; gap: 0.5rem;"><span style="font-size: 0.9rem; color: #1f2937; font-weight: 500;">${escapeHtml(breakdownName)}</span><span style="font-size: 0.8rem; color: #6b7280;">(${breakdownData.count || 0} transactions)</span></div><div style="text-align: right;"><div style="font-weight: 600; color: #1f2937; font-size: 0.95rem;">$${parseFloat(breakdownData.total || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</div><div style="font-size: 0.75rem; color: #6b7280;">${breakdownData.percentage ? breakdownData.percentage.toFixed(1) : '0.0'}% of ${escapeHtml(sourceName)}</div></div></div>`;
            });
            breakdownHTML += '</div>';
        }
        sourceCard.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.75rem;"><h4 style="margin: 0; font-size: 1.1em; color: #1f2937; font-weight: 600;">${escapeHtml(sourceName)}</h4><span style="font-weight: 700; color: #1a472a; font-size: 1.5em;">$${parseFloat(sourceData.total || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></div><div style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #6b7280; margin-bottom: 0.75rem;"><span>${sourceData.count.toLocaleString()} transactions</span><span style="font-weight: 600;">${sourceData.percentage.toFixed(1)}% of total</span></div><div style="height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;"><div style="height: 100%; background: #1a472a; width: ${sourceData.percentage}%; transition: width 0.3s ease;"></div></div>${breakdownHTML}`;
        sourcesList.appendChild(sourceCard);
    });
}

function updateExpensesByType(data) {
    if (!data || !data.sources) return;
    const sectionContainer = document.getElementById('expenses-by-type-section-container');
    if (sectionContainer) sectionContainer.style.display = 'block';
    const expensesList = document.getElementById('expenses-by-type-list');
    if (!expensesList) return;
    expensesList.innerHTML = '';
    const expenseTypes = Object.entries(data.sources).sort((a, b) => Math.abs(b[1].total) - Math.abs(a[1].total));
    expenseTypes.forEach(([typeName, typeData]) => {
        const expenseCard = document.createElement('div');
        expenseCard.className = 'board-analysis-card expense-card';
        const isNegative = typeData.total < 0;
        const color = isNegative ? '#10b981' : '#dc2626';
        if (isNegative) expenseCard.style.borderLeftColor = '#10b981';
        expenseCard.innerHTML = `<div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.75rem;"><h4 style="margin: 0; font-size: 1.1em; color: #1f2937; font-weight: 600;">${escapeHtml(typeName)}</h4><span style="font-weight: 700; color: ${color}; font-size: 1.5em;">${isNegative ? '-' : ''}$${Math.abs(parseFloat(typeData.total || 0)).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</span></div><div style="display: flex; justify-content: space-between; font-size: 0.9rem; color: #6b7280; margin-bottom: 0.75rem;"><span>${typeData.count.toLocaleString()} transactions</span><span style="font-weight: 600;">${Math.abs(typeData.percentage).toFixed(1)}% of total</span></div><div style="height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden;"><div style="height: 100%; background: ${color}; width: ${Math.abs(typeData.percentage)}%; transition: width 0.3s ease;"></div></div>`;
        expensesList.appendChild(expenseCard);
    });
}

function updatePrograms(data) {
    const sectionContainer = document.getElementById('programs-section-container');
    if (sectionContainer) sectionContainer.style.display = 'block';
    if (!data) {
        const tbody = document.getElementById('programs-tbody');
        if (tbody) tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No program data available</td></tr>';
        return;
    }
    const tbody = document.getElementById('programs-tbody');
    const coverageEl = document.getElementById('programs-coverage');
    if (!tbody) return;
    if (coverageEl && data.coverage) coverageEl.textContent = data.coverage;
    tbody.innerHTML = '';
    const programs = data.programs ? Object.entries(data.programs) : [];
    if (programs.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No programs found. Programs are created in QuickBooks as Classes.</td></tr>';
        return;
    }
    const programsWithData = programs.filter(([name, data]) => (data.revenue || 0) > 0 || (data.expenses || 0) > 0);
    const programsToShow = programsWithData.length > 0 ? programs : programs.slice(0, 20);
    if (programsToShow.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No programs found. Programs are created in QuickBooks as Classes.</td></tr>';
        return;
    }
    programsToShow.forEach(([programName, programData], index) => {
        const row = document.createElement('tr');
        row.style.cssText = `border-bottom: 1px solid var(--border-color);`;
        if (index % 2 === 0) row.style.backgroundColor = 'var(--bg-secondary)';
        const netIncome = programData.net_income || 0;
        const profitMargin = programData.profit_margin || 0;
        const netColor = netIncome >= 0 ? '#10b981' : '#dc2626';
        const marginColor = profitMargin >= 0 ? '#10b981' : '#dc2626';
        const revenue = parseFloat(programData.revenue || 0);
        const expenses = parseFloat(programData.expenses || 0);
        const hasData = revenue > 0 || expenses > 0;
        const revenueColor = hasData ? 'var(--text-primary)' : '#9ca3af';
        const expensesColor = hasData ? 'var(--text-primary)' : '#9ca3af';
        row.innerHTML = `<td style="padding: 0.75rem; font-weight: 500; color: ${hasData ? 'var(--text-primary)' : '#9ca3af'};">${escapeHtml(programName)}</td><td style="padding: 0.75rem; text-align: right; color: ${revenueColor};">$${revenue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; color: ${expensesColor};">$${expenses.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${netColor};">$${parseFloat(netIncome).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${marginColor};">${profitMargin.toFixed(1)}%</td>`;
        tbody.appendChild(row);
    });
}

function updateTopDonors(data) {
    const sectionContainer = document.getElementById('top-donors-section-container');
    if (sectionContainer) sectionContainer.style.display = 'block';
    if (!data || !data.donors) {
        const tbody = document.getElementById('top-donors-tbody');
        if (tbody) tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No donor data available</td></tr>';
        return;
    }
    const tbody = document.getElementById('top-donors-tbody');
    const coverageEl = document.getElementById('donor-coverage');
    const coverageDetailsEl = document.getElementById('donor-coverage-details');
    if (!tbody) return;
    if (coverageEl && data.coverage) coverageEl.textContent = data.coverage;
    if (coverageDetailsEl && data.coverage_details) {
        const details = data.coverage_details;
        coverageDetailsEl.textContent = `${details.donations_with_contact.toLocaleString()} of ${details.total_donations.toLocaleString()} donations`;
    }
    tbody.innerHTML = '';
    if (data.donors.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No donor data available</td></tr>';
        return;
    }
    data.donors.forEach((donor, index) => {
        const row = document.createElement('tr');
        row.style.cssText = `border-bottom: 1px solid var(--border-color);`;
        if (index % 2 === 0) row.style.backgroundColor = 'var(--bg-secondary)';
        const lastDonation = donor.last_donation ? new Date(donor.last_donation).toLocaleDateString() : '‚Äî';
        const donorName = donor.name && donor.name.trim() ? escapeHtml(donor.name) : `Anonymous ${index + 1}`;
        row.innerHTML = `<td style="padding: 0.75rem; font-weight: 500; color: var(--text-primary);">${donorName}</td><td style="padding: 0.75rem; text-align: right; font-weight: 600; color: #1a472a;">$${parseFloat(donor.total_amount || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: center; color: var(--text-primary);">${donor.donation_count || 0}</td><td style="padding: 0.75rem; text-align: right; color: var(--text-secondary);">$${parseFloat(donor.avg_donation || 0).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: center; color: var(--text-secondary); font-size: 0.9rem;">${lastDonation}</td>`;
        tbody.appendChild(row);
    });
}

function updateFunds(data) {
    const sectionContainer = document.getElementById('funds-section-container');
    if (sectionContainer) {
        sectionContainer.style.display = 'block';
    } else {
        return;
    }
    if (!data) {
        const tbody = document.getElementById('funds-tbody');
        if (tbody) tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No fund data available</td></tr>';
        return;
    }
    const tbody = document.getElementById('funds-tbody');
    if (!tbody) return;
    const coverageEl = document.getElementById('funds-coverage');
    const coverageDetailsEl = document.getElementById('funds-coverage-details');
    if (coverageEl) {
        if (data.coverage && data.coverage.includes('fund_id not populated')) {
            coverageEl.textContent = 'No Data';
        } else {
            coverageEl.textContent = data.coverage || 'Partial';
        }
    }
    if (coverageDetailsEl && data.coverage) coverageDetailsEl.textContent = data.coverage;
    tbody.innerHTML = '';
    const funds = data.funds ? Object.entries(data.funds) : [];
    if (funds.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-secondary);">No funds found. Funds are created in Aplos.</td></tr>';
        return;
    }
    funds.forEach(([fundName, fundData], index) => {
        const row = document.createElement('tr');
        row.style.cssText = `border-bottom: 1px solid var(--border-color);`;
        if (index % 2 === 0) row.style.backgroundColor = 'var(--bg-secondary)';
        const netIncome = fundData.net_income || 0;
        const profitMargin = fundData.profit_margin || 0;
        const netColor = netIncome >= 0 ? '#10b981' : '#dc2626';
        const marginColor = profitMargin >= 0 ? '#10b981' : '#dc2626';
        const revenue = parseFloat(fundData.revenue || 0);
        const expenses = parseFloat(fundData.expenses || 0);
        const hasData = revenue > 0 || expenses > 0;
        const fundType = fundData.fund_type || 'Unrestricted';
        let typeColor = '#6b7280';
        if (fundType.includes('Restricted')) typeColor = '#f59e0b';
        else if (fundType.includes('Unrestricted')) typeColor = '#10b981';
        const noDataMessage = !hasData ? ' (fund exists but cannot be linked to donations/transactions)' : '';
        row.innerHTML = `<td style="padding: 0.75rem; font-weight: 500; color: ${hasData ? 'var(--text-primary)' : '#9ca3af'};">${escapeHtml(fundName)}${noDataMessage ? `<span style="font-size: 0.75rem; font-weight: normal; color: #6b7280; display: block; margin-top: 0.25rem;">${noDataMessage}</span>` : ''}</td><td style="padding: 0.75rem; color: ${typeColor}; font-size: 0.9rem;">${escapeHtml(fundType)}</td><td style="padding: 0.75rem; text-align: right; color: ${hasData ? 'var(--text-primary)' : '#9ca3af'};">$${revenue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; color: ${hasData ? 'var(--text-primary)' : '#9ca3af'};">$${expenses.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${netColor};">$${parseFloat(netIncome).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td><td style="padding: 0.75rem; text-align: right; font-weight: 600; color: ${marginColor};">${profitMargin.toFixed(1)}%</td>`;
        tbody.appendChild(row);
    });
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üöÄ Initializing app for tenant:', TENANT_ID);
    
    // Check if there's a search parameter in the URL (from business-data.html tile clicks)
    const urlParams = new URLSearchParams(window.location.search);
    const searchEntityType = urlParams.get('search');
    if (searchEntityType) {
        // Remove the search parameter from URL
        window.history.replaceState({}, document.title, window.location.pathname);
        // Open entity data modal for the searched entity type
        setTimeout(() => {
            const entityName = searchEntityType;
            if (typeof window.showEntityData === 'function') {
                window.showEntityData(searchEntityType, entityName);
            }
        }, 1000); // Wait for Crema data to load
    }
    
    try {
        // Static mode: No readiness check needed
        
        // Ensure funds section is visible (fallback in case data loading fails)
        setTimeout(() => {
            const fundsSection = document.getElementById('funds-section-container');
            if (fundsSection && fundsSection.style.display === 'none') {
                console.log('üí∞ Ensuring funds section is visible (fallback)');
                fundsSection.style.display = 'block';
                // Try to load funds data if not already loaded
                const tbody = document.getElementById('funds-tbody');
                if (tbody && tbody.innerHTML.includes('Loading...')) {
                    // Data might still be loading, check again in a moment
                    setTimeout(() => {
                        if (tbody.innerHTML.includes('Loading...')) {
                            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 2rem; color: var(--text-secondary);">Loading fund data...</td></tr>';
                        }
                    }, 2000);
                }
            }
        }, 1000);
        
        // Auto-refresh disabled per user request
        // Refresh data periodically (parallelize for performance)
        // Insights now auto-refresh along with metrics and Crema data
        // setInterval(async () => {
        //     const timeRangeSelect = document.getElementById('time-range-select');
        //     const timeRange = timeRangeSelect ? timeRangeSelect.value : 'month';
        //     await Promise.all([
        //         fetchCremaData(),
        //         fetchMetrics(),
        //         fetchInsights(timeRange)  // Auto-refresh insights
        //     ]);
        // }, 60000);
        
        // Recommendations disabled for performance
        // const refreshRecommendationsBtn = document.getElementById('refresh-recommendations-btn');
        // if (refreshRecommendationsBtn) {
        //     refreshRecommendationsBtn.addEventListener('click', async () => {
        //         const timeRangeSelect = document.getElementById('time-range-select');
        //         const timeRange = timeRangeSelect ? timeRangeSelect.value : 'month';
        //         refreshRecommendationsBtn.style.cursor = 'wait';
        //         refreshRecommendationsBtn.disabled = true;
        //         document.body.style.cursor = 'wait';
        //         try {
        //             await fetchRecommendations(timeRange);
        //         } finally {
        //             refreshRecommendationsBtn.style.cursor = 'pointer';
        //             refreshRecommendationsBtn.disabled = false;
        //             document.body.style.cursor = 'default';
        //         }
        //     });
        // }
        
        // Business views removed - no refresh button needed
    } catch (error) {
        console.error('‚ùå App initialization error:', error);
        showError('Failed to initialize app: ' + error.message, 'metrics');
    }
});

    </script>
</body>
</html>

